# 4주차: CSS와 라이브러리, 언제 어떤 걸 써야 할까?

## 1. CSS 애니메이션의 한계: 실전 사례

-   **중복 이벤트**: transitionend가 여러 번 발생해, 한 번만 처리해야 할 로직이 여러 번 실행됨
-   **상태 꼬임**: 빠른 열림/닫힘 등 사용자의 빠른 액션에 따라 DOM 상태 관리가 꼬임
-   **복잡한 시퀀스 불가**: A → B → C처럼 여러 애니메이션을 순차적으로 자연스럽게 실행하기 어려움
-   **재사용 어려움**: 매번 class, event를 직접 관리해야 하므로, 컴포넌트화/재사용이 번거로움

### 실제 코드 예시: Fade 모달 (3주차)

```tsx
const Fade = ({
    children,
    visible,
}: {
    children: React.ReactNode;
    visible: boolean;
}) => {
    const [shouldRender, setShouldRender] = useState(false);

    useEffect(() => {
        if (visible) setShouldRender(true);
    }, [visible]);

    const handleTransitionEnd = () => {
        if (!visible) setShouldRender(false);
    };

    return shouldRender ? (
        <div
            className={`fade${visible ? " show" : ""}`}
            onTransitionEnd={handleTransitionEnd}
        >
            {children}
        </div>
    ) : null;
};
```

**문제점**

-   빠르게 열고 닫으면 transitionend가 여러 번 발생해 상태 꼬임
-   여러 애니메이션을 순차적으로 실행하려면 추가 로직 필요
-   Fade 외에 Slide, Scale 등 다양한 효과를 추가하려면 컴포넌트/로직이 계속 늘어남

---

## 2. 라이브러리의 장점: 복잡한 UI/UX에 강하다

### ssgoi 간단한 fade 예시

```ts
import {Ssgoi} from "@ssgoi/react";
import {fade} from "@ssgoi/react/view-transitions";

1; // default
const config = {
    defaultTransition: fade(),
};

2; // custom
const config = {
    defaultTransition: fade({
        spring: {
            stiffness: 400, // 빠른 전환
            damping: 35, // 부드러운 마무리
        },
    }),
};

export default function App() {
    return <Ssgoi config={config}></Ssgoi>;
}
```

-   **추상화된 API**: 복잡한 애니메이션 로직을 간단한 props로 제어
-   **상태 기반 제어**: React state와 자연스럽게 연동, 상태 변화에 따라 애니메이션 자동 실행
-   **복잡한 시퀀스/제스처 지원**: 드래그, 스프링, stagger 등 고급 효과 지원
-   **생산성**: 코드량 감소, 가독성 증가, 유지보수 쉬움

**장점**

-   간단한 애니메이션 처리 + 기존코드와 연동도 OK
-   상태 변화에 따라 자동으로 Fade in/out
-   exit 애니메이션 후 자동 언마운트
-   여러 효과(Scale, Slide 등)도 props만 바꿔서 쉽게 적용

사용하려는 의도에 맞게 라이브러리 선택

---

## 3. 언제 CSS만 써도 충분한가? 언제 라이브러리를 써야 하는가?

| 상황                             | CSS만 사용 | 라이브러리 사용 |
| -------------------------------- | ---------- | --------------- |
| 단순 전환                        | O          |                 |
| DOM을 지우지 않는 단순 효과      | O          |                 |
| 페이지 전환, 언마운트 애니메이션 |            | O               |
| 복잡한 시퀀스/제스처             |            | O               |
| 다양한 효과(스프링, 드래그 등)   |            | O               |
| 재사용/유지보수                  | △          | O               |

## 4. css 애니메이션 커스텀 사이트 animista 소개

미리 만들어진 다양한 CSS 애니메이션들을 브라우저에서 실시간으로 설정(지연시간, 반복, 이징, duration 등)을 튜닝해보고,
마음에 들면 CSS 코드만 복사해서 프로젝트에 붙일 수 있는 웹 툴

-   여러 애니메이션 효과(category)들을 카테고리별로 나누어 제공하고, 사용하는 애니메이션만 선택해 다운로드하거나 복사 가능함.

-   생성된 애니메이션 코드는 개인/상업용 모두 사용 가능하고, 라이선스는 FreeBSD

\*FreeBSD 란?  
원래의 저작권 고지(copyright notice)와 라이선스 문구를 보존해야 한다는 것

-   여기서는 copy 시 주석으로 아래 하단을 표기 해줘야 한다는 의미

```css
/* ----------------------------------------------
 * Generated by Animista on 2025-9-15 20:35:37
 * Licensed under FreeBSD License.
 * See http://animista.net/license for more info. 
 * w: http://animista.net, t: @cssanimista
 * ---------------------------------------------- */
```

-   만약 고지하고 싶지 않다면 동일한 코드를 사용하지 않고, 코드 베이스를 보고 커스텀 하기

주소 - https://animista.net/

**장점**

-   애니메이션 처리 시 시간절약
-   쉬운 커스터마이징
-   필요 코드만 제공 (box 라던지, container 등은 본인이 만들어둔 요소로 사용, 결론적으로 animate만 보고 따라 하면 됨)
-   FreeBSD 라이선스 이므로 적절하게 이용하면 무료로 애니메이션 사용 가능
-   다양한 카테고리 제공 (background, text 등)

**사용법**

1. 홈페이지 접속 후 원하는 카테고리 클릭
2. options에서 본인이 바꾸고 싶은 옵션을 선택
3. 우측 replay로 애니메이션 동작 확인
4. Generate Code 클릭 후 커스텀

---

## 결론

-   단순하고 반복적이지 않은 애니메이션은 CSS만으로도 충분히 구현할 수 있습니다. + 애니메이션 툴, 다양한 예시 코드들 사용 가능
-   하지만 페이지 전환, 언마운트, 복잡한 시퀀스, 다양한 효과 등 유지보수와 확장성이 중요한 경우에는 ssgoi, Framer Motion, React Spring 같은 라이브러리를 적극적으로 활용하는 것이 생산성과 협업에 더 유리합니다.
-   상황에 따라 적절한 도구를 선택하는 것이 가장 중요합니다.
