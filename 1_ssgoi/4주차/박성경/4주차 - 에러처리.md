### Graceful Degradation (품위 있게 망가지기)

- SSGOI에서 사용한 에러 처리 방법
- 애니메이션이 실패하거나 지원이 안 될 때도 일단 최소한 라우팅 동작은 되게 하기
- 오류도 정상 동작처럼 처리, 밖에서 try-catch 문 사용하지 않고, 비즈니스 로직으로 흡수
- Promise + Timeout 패턴 사용

```ts
// ✅ 무한 대기(deadlock) 방지 + Graceful Degradation
const hasFromNode = await new Promise<boolean>((resolve) => {
  if (fromNode) {
    resolve(true);
  } else {
    resolver = resolve;
    // 타임아웃으로 무한 대기 방지
    setTimeout(() => {
      resolver = null;
      resolve(false); // 애니메이션이 실패해도 reject가 아닌 false로 처리
    }, timeout);
  }
});

if (!hasFromNode) {
  // 실패해도 앱이 멈추지 않음
  return { spring, tick: () => {} };
}
```

1. Fallback 값 제공
```ts
function parseJSON(str: string) {
  try {
    return JSON.parse(str);
  } catch {
    // ✅ 실패하면 기본값 제공
    return {};
  }
}
```
→ JSON 파싱 실패해도 앱 안 죽고, 빈 객체로 계속 동작.

2. 옵셔널 체이닝 + 기본값
```ts
const username = user?.profile?.name ?? "Guest";
```
→ user가 없어도 TypeError 안 터지고, fallback "Guest"로 처리.

3. Silent Fail (로그만 남기기)
```ts
try {
  runAnimation();
} catch (e) {
  console.warn("애니메이션 실패, 무시함:", e);
}
```
→ UX에 영향 없는 기능은 조용히 무시하고 로그만. (스관시에서 주로 쓰는 방식)

### 운영 서비스들에서의 에러 처리 방법
목표: 적은 코드로 에러 핸들링하기

1. Error Boundary/전역 핸들러 → 앱 전체가 죽지 않게 방어
2. 기능별 fallback/Graceful Degradation → 유저 경험을 최소한 보장

1. 에러 바운더리
```ts
export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
    constructor(props: ErrorBoundaryProps) {
        super(props);
        this.state = { hasError: false, error: null };
    }

    static getDerivedStateFromError(error: Error) {
        return { hasError: true, error };
    }

    // 로그에 에러 출력
    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        console.error(error, errorInfo);
    }
    
    // 다시 시도하기
    reset = () => {
        this.setState({ hasError: false, error: null });
    };

    render() {
        if (this.state.hasError) {
          // ✅ fallback이 있으면 그걸 쓰고, 없으면 기본 UI
          return this.props.fallback ?? (
            <div>
              <p>{this.state.error?.message ?? "알 수 없는 오류가 발생했습니다."}</p>
              <button onClick={this.reset}>다시 시도</button>
            </div>
          );
        }

        return this.props.children;
  }
}
```

```ts
<ErrorBoundary fallback={<div>문제가 발생했습니다. 다시 시도해주세요.</div>}>
  <PaymentWidget />
</ErrorBoundary>
```
→ 런타임 에러가 나도 앱 전체가 흰 화면으로 날아가지 않고, 특정 컴포넌트만 fallback으로 대체.

2. Result 패턴
```ts
function toResult<T>(fn: () => T): Result<T> {
  try {
    return { ok: true, value: fn() };
  } catch (e) {
    return { ok: false, error: e };
  }
}

const result = toResult(() => doSomethingDangerous());
```
→ Result 패턴으로 함수의 리턴값을 감싸기
→ 호출하는 쪽에서 일일이 try/catch를 안 하고 ok 값으로만 구분 가능.