### 1. React 커스텀 훅과 클래스의 비교, 클로저와 useCallback
```ts
function createAnimator() {
  let currentValue = 0;
  let isAnimating = false;

  return {
    forward() {
      isAnimating = true;
      currentValue += 1;
    },
    stop() {
      isAnimating = false;
    },
    getValue() {
      return currentValue;
    }
  }
}
```

```ts
import { useRef, useCallback } from "react";

function useAnimator(initialValue: number = 0) {
  const currentValue = useRef(initialValue);
  const isAnimating = useRef(false);

  const forward = useCallback(() => {
    isAnimating.current = true;
    currentValue.current += 1;
  }, []);

  const stop = useCallback(() => {
    isAnimating.current = false;
  }, []);

  const getValue = useCallback(() => currentValue.current, []);

  return { currentValue, isAnimating, forward, stop, getValue };
}
```

- React의 커스텀 훅은 클로저를 이용하여 구현
- 커스텀 훅도 함수니까 내부에서 만드는 메서드는 매번 새로 생성
- 그 자체로는 성능에 큰 문제 없음
- 하지만 커스텀 훅의 메서드를 자식 컴포넌트에게 넘겨줄때, 부모가 렌더링되면 자식(memo 사용)까지 리렌더링될 수 있음.
- 자식 컴포넌트가 함수 재생성에 의해 리렌더링되어 성능에 이슈가 생기면 `useCallback`으로 제어


### 2. Web Worker를 통한 성능 개선
- 자바스크립트는 싱글 스레드 언어지만 웹 API인 Web Worker를 사용하면 병렬로 작업 가능.
- 무거운 작업 시 메인 스레드(UI) 말고 Web Worker에서 따로 계산하고 결과만 받기
- 애니메이션, 이미지/비디오, 머신러닝용 등 대규모 데이터 가공 등 특수한 경우에 사용
- postMessage를 이용하여 워커와 통신하기 때문에 직렬화/역직렬화 비용이 붙음
- 그래서 입출력은 간단하고 계산이 복잡하다면 효율 상승

```ts
// 📍 animator.ts - 메인 스레드에서 복잡한 계산
animate({
  from: this.currentValue,
  to: target,
  stiffness: this.options.spring.stiffness,  // 복잡한 물리 계산
  damping: this.options.spring.damping,
  velocity: this.velocity * 1000
});
```

```ts
// ✅ 복잡한 계산을 워커로 이동
class AnimationWorker {
  private worker: Worker;
  
  // 메인 스레드에서 메시지를 보내면 워커 안에 있는 onmessage에서 감지 후 계산 시작
  // 계산이 끝나면 결과를 메인 스레드로 돌려줌
  
  constructor() {
    this.worker = new Worker(`
      self.onmessage = (e) => {
        const { type, data } = e.data;
        if (type === 'calculateSpring') {
          const result = calculateSpringPhysics(data);
          self.postMessage({ type: 'springResult', result });
        }
      };
    `);
  }
  
  calculateSpring(params: SpringParams): Promise<SpringResult> {
    return new Promise((resolve) => {
      this.worker.postMessage({ type: 'calculateSpring', data: params });
      this.worker.onmessage = (e) => {
        if (e.data.type === 'springResult') {
          resolve(e.data.result);
        }
      };
    });
  }
}
```

### 3. GPU 가속 최적화
- 쓰고이는 전반적으로 잘 최적화되어 있음
- 브라우저 렌더링 시 reflow, repaint 과정 최대한 일어나지 않게 함
- GPU 합성 과정인 composite 단계만 타도록 하는 것이 이상적

| 구분                               | 속성 예시                                                                                        | 동작 단계                      | 특징                                   | 성능 영향                   |
| -------------------------------- | -------------------------------------------------------------------------------------------- | -------------------------- | ------------------------------------ | ----------------------- |
| ✅ **좋은 예시 (GPU Composite-only)** | `transform`, `opacity`, 일부 `clip-path`, `filter`                                             | Composite                  | GPU에서 바로 합성만 함. Layout/Paint 건드리지 않음 | 애니메이션이 부드럽고 60fps 유지 쉬움 |
| ❌ **안 좋은 예시 (reflow/repaint 유발)**    | `top`, `left`, `width`, `height`, `margin`, `padding`, `background-*`, `box-shadow`(특히 blur) | Layout → Paint → Composite | 레이아웃 다시 계산하고 픽셀 다시 칠해야 함             | CPU 부하 ↑, 프레임 드랍 ↑, 느려짐 |
