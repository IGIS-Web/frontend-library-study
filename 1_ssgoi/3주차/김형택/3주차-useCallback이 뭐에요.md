
# 리액트 함수형 컴포넌트 최적화

리액트에서 함수형 컴포넌트 사용 시 발생할 수 있는 성능 최적화와 관련된 주요 개념들을 설명합니다.

## 1. 함수형 컴포넌트에서의 함수

- 리액트에서 함수형 컴포넌트를 사용하면, 컴포넌트는 **상태(state)**나 **속성(props)** 변경에 따라 **렌더링**됩니다.
- **컴포넌트가 렌더링될 때마다** 그 안에 포함된 **함수도 새로 정의**됩니다.
- 렌더링될 때마다 **새로 정의되는 함수**를 자식 컴포넌트에게 전달하면, 자식 컴포넌트가 **불필요하게 리렌더링**될 수 있습니다.

### 예시

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = () => setCount(count + 1);

  return <Child onClick={handleClick} />;
}
```

위 코드에서 `handleClick` 함수는 **렌더링할 때마다 새로 정의**됩니다. 따라서 `Child` 컴포넌트는 **불필요하게 리렌더링**될 수 있습니다.

---

## 2. `useCallback` 훅의 역할

`useCallback` 훅은 **함수가 불필요하게 새로 생성되는 것을 방지**하려고 사용됩니다.  
**의존성 배열**에 있는 값들이 변경되지 않는 한, 함수는 **새로 생성되지 않**습니다.

### 핵심
- **`useCallback`**은 함수가 **재정의되는 것을 최적화**하여 성능을 향상시키는 데 사용됩니다.
- 핵심은 **불필요한 리렌더링을 막는 것**입니다. 리렌더링에 많은 자원이 들 때, 최적화가 필요한 상황에서 사용됩니다.

### 예시

```jsx
const memoizedCallback = useCallback(() => {
  // some logic
}, [dependency]);
```

---

## 3. `React.memo` 사용법

`React.memo`는 **컴포넌트의 props가 변경되지 않으면 리렌더링을 방지**하는 기능을 제공합니다.  
리액트에서 자주 변경되지 않는 props를 가진 컴포넌트에서 성능 최적화를 위해 사용됩니다.

### 장점 (Good)
- **불필요한 리렌더링 방지**: props가 변경되지 않으면 리렌더링을 막습니다.
- **성능 최적화**: 많은 자식 컴포넌트가 있을 때 유용합니다.
- **깊은 비교 지원 가능**: 복잡한 객체를 props로 받을 때 유리합니다.

### 단점 (Bad)
- **비교 함수 추가 비용**: 깊은 비교가 필요한 경우 성능 부담이 커질 수 있습니다.
- **불필요한 최적화**: 최적화를 남발하면 코드가 복잡해질 수 있습니다.
  - 자주 변경되지 않는 props에 `React.memo`를 적용하면 성능 향상이 없을 수 있습니다.
- **초기 렌더링 지연**: 처음 렌더링 시 비교가 추가되어 **속도가 느려질 수 있음**.

### 예시

```jsx
const MemoizedComponent = React.memo(Component);
```

---

## 결론

- **`useCallback`**과 **`React.memo`**는 리액트에서 **불필요한 리렌더링을 방지하고 성능을 최적화**하는 중요한 도구입니다.
- 하지만 최적화가 **불필요하게 남발**되면 오히려 **코드가 복잡해지고 성능에 부담**을 줄 수 있으므로, **필요한 경우에만 사용하는 것이 중요**합니다.
