root: packages/react/src/lib <br>
ssgoi.tsx

### 리액트에서의 플로우
1. 사용자가 페이지 이동
2. 리액트의 Router가 특정 path로의 페이지 전환을 감지 (path별 조건 처리)
3. 언마운트 시작, cleanup 함수(return 에 있는 콜백함수) 내에서 out 애니메이션 시작 -> runExitTransition
4. 새 컴포넌트 마운트 시작, ref 콜백이 실행됨. 
    <div ref={transition(getTransition(id)) data-ssgoi-transition={id}>
    (react ref 콜백 패턴 -> 엘리먼트가 DOM에 연결될 때 자동 호출, id를 통해 transition 설정(=createTransitionCallback)을 가져와서 해당 엘리먼트에 적용함)
    (data-ssgoi-transition은 디버깅을 위한 것? 어떤 transition 이 적용되었는지 확인용)
5. TransitionCallback에서 runEntrance 함수를 실행, 거기에 실질적인 애니메이션 로직 있음

(+) Popmotion의 Spring이라는 써드파티 사용하여 자연스럽게 움직이도록 함


### types.tsx
```ts
export type GetTransitionConfig<TContext = undefined, TAnimationValue = number> =
  TContext extends undefined
    ? (node: HTMLElement) => TransitionConfig<TAnimationValue> | Promise<TransitionConfig<TAnimationValue>>
    : (
        node: HTMLElement,
        context: TContext
      ) => TransitionConfig<TAnimationValue> | Promise<TransitionConfig<TAnimationValue>>;

export type Transition<TContext = undefined, TAnimationValue = number> = {
  in?: GetTransitionConfig<TContext, TAnimationValue>;
  out?: GetTransitionConfig<TContext, TAnimationValue>;
};
```

- 특징 1: TContext가 undefined일 경우, 그렇지 않을 경우에 대해 타입을 다르게 정함
- 특징 2: Promise일때와 아닐 때 둘다 지원함(개발자 편의를 위해) -> 위의 TransitionConfig부분, 그리고 Promise.resolve(transition.in(element)) 부분
- 특징 3: TAnimationValue를 제네릭으로 열어두고 number, object 타입을 받음.
    미리 만들어진 transition(ex: fade())을 사용할 때는 number, 커스텀 transition은 object를 받음

```ts
// 예시: 디폴트
transition({
  key: 'card',
  in: fadeIn(),      // { opacity: 0 } → { opacity: 1 }
  out: slideUp()     // { y: 0 } → { y: -100 }
})
```
```ts
// 예시: 커스텀
transition({
  key: 'custom',
  in: { 
    from: { progress: 0, intensity: 0 },
    to: { progress: 100, intensity: 50 }
  },
  out: {
    from: { progress: 100, intensity: 50 },
    to: { progress: 0, intensity: 0 }
  }
})
```