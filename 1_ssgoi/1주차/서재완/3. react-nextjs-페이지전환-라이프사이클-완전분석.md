# React & Next.js 페이지 전환 라이프사이클 완전 분석

## 개요

React와 Next.js에서 페이지 전환이 어떻게 일어나는지, 그리고 SSGOI가 어떤 시점에 개입하는지 라이프사이클 관점에서 상세히 분석합니다.

## 1. React 컴포넌트 라이프사이클 기본 원리

### 1.1 함수 컴포넌트의 라이프사이클
```typescript
function MyComponent() {
  // 1. 렌더링 (매번 실행)
  console.log('Component render');

  // 2. useLayoutEffect (DOM 변경 직후, 브라우저 페인트 전)
  useLayoutEffect(() => {
    console.log('useLayoutEffect - mount/update');
    return () => {
      console.log('useLayoutEffect cleanup - unmount/update 전');
    };
  }, []);

  // 3. useEffect (브라우저 페인트 후)
  useEffect(() => {
    console.log('useEffect - mount/update');
    return () => {
      console.log('useEffect cleanup - unmount/update 전');
    };
  }, []);

  // 4. ref callback
  const refCallback = useCallback((element: HTMLElement | null) => {
    if (element) {
      console.log('ref callback - mount');
      return () => {
        console.log('ref callback cleanup - unmount');
      };
    }
  }, []);

  return <div ref={refCallback}>Content</div>;
}
```

### 1.2 라이프사이클 실행 순서 (마운트)
```
1. Component render
2. DOM 변경 반영
3. useLayoutEffect 실행 (동기적, 브라우저 페인트 블록)
4. 브라우저 페인트/리페인트
5. useEffect 실행 (비동기적)
6. ref callback 실행 (DOM 요소 생성 후)
```

### 1.3 라이프사이클 실행 순서 (언마운트)
```
1. React: 언마운트 결정
2. ref callback cleanup 실행 ← 🔥 SSGOI 개입 시점!
3. useLayoutEffect cleanup 실행
4. useEffect cleanup 실행  
5. DOM에서 요소 완전 제거
6. 메모리에서 컴포넌트 인스턴스 제거
```

## 2. React Router 페이지 전환 상세 과정

### 2.1 React Router v6 동작 원리

React Router는 **클라이언트 사이드 라우팅**을 사용:
- URL 변경을 감지
- 브라우저 새로고침 없이 컴포넌트만 교체
- `history.pushState()` API 사용

### 2.2 페이지 전환 과정 ("/home" → "/about")

#### Phase 1: 네비게이션 트리거
```typescript
// 사용자가 Link 클릭 또는 navigate() 호출
<Link to="/about">Go to About</Link>
// 또는
const navigate = useNavigate();
navigate('/about');
```

**내부 동작:**
1. React Router가 URL 변경 감지
2. `history.pushState('/about', ...)` 실행
3. 브라우저 주소창 변경 (새로고침 없음)
4. Router 컴포넌트 리렌더링 트리거

#### Phase 2: 라우트 매칭 및 컴포넌트 결정
```typescript
// React Router 내부 매칭 로직
const routes = [
  { path: "/home", element: <HomePage /> },
  { path: "/about", element: <AboutPage /> },
];

// "/about" 경로에 매칭되는 컴포넌트 찾기
const matchedRoute = matchRoutes(routes, "/about");
// → { path: "/about", element: <AboutPage /> }
```

#### Phase 3: 이전 컴포넌트 언마운트 시작
```typescript
// HomePage 컴포넌트 언마운트 과정
function HomePage() {
  useLayoutEffect(() => {
    return () => {
      console.log('1. HomePage useLayoutEffect cleanup');
    };
  }, []);

  useEffect(() => {
    return () => {
      console.log('2. HomePage useEffect cleanup');
    };
  }, []);

  const refCallback = (element) => {
    if (element) {
      return () => {
        console.log('0. HomePage ref cleanup'); // 🔥 가장 먼저!
      };
    }
  };

  return (
    <SsgoiTransition id="/home">
      <div ref={refCallback}>
        <h1>Home Page</h1>
      </div>
    </SsgoiTransition>
  );
}
```

**언마운트 순서:**
```
0. ref callback cleanup (SSGOI 개입!)
1. useLayoutEffect cleanup
2. useEffect cleanup
3. DOM 요소 제거
```

#### Phase 4: 새 컴포넌트 마운트 시작
```typescript
// AboutPage 컴포넌트 마운트 과정
function AboutPage() {
  console.log('1. AboutPage render');

  useLayoutEffect(() => {
    console.log('3. AboutPage useLayoutEffect');
  }, []);

  useEffect(() => {
    console.log('5. AboutPage useEffect');
  }, []);

  const refCallback = (element) => {
    if (element) {
      console.log('4. AboutPage ref callback');
    }
  };

  return (
    <SsgoiTransition id="/about">
      <div ref={refCallback}>
        <h1>About Page</h1>
      </div>
    </SsgoiTransition>
  );
}
```

**마운트 순서:**
```
1. AboutPage render
2. DOM 요소 생성
3. useLayoutEffect 실행
4. ref callback 실행 (SSGOI 입장 애니메이션!)
5. useEffect 실행
```

### 2.3 React Router 전환 타임라인
```
Time: 0ms
├─ 사용자 Link 클릭
├─ React Router URL 변경 감지
├─ Router 컴포넌트 리렌더링 시작

Time: ~1ms
├─ HomePage 언마운트 결정
├─ HomePage ref cleanup → SSGOI OUT 시작 🔥
├─ HomePage useLayoutEffect cleanup
├─ HomePage useEffect cleanup

Time: ~2ms  
├─ AboutPage 렌더링 시작
├─ AboutPage DOM 요소 생성
├─ AboutPage useLayoutEffect 실행

Time: ~3ms
├─ AboutPage ref callback → SSGOI IN 시작 🔥
├─ SSGOI Promise 동기화 완료
├─ OUT/IN 애니메이션 동시 시작

Time: ~300ms (애니메이션 지속시간)
├─ 애니메이션 완료
├─ 복제본 제거
```

## 3. Next.js 페이지 전환 상세 과정

### 3.1 Next.js App Router vs Pages Router

#### Pages Router (레거시)
```
pages/
├─ index.js      → /
├─ about.js      → /about
└─ _app.js       → 앱 wrapper
```

#### App Router (Next.js 13+)
```
app/
├─ page.tsx      → /
├─ about/
│  └─ page.tsx   → /about
└─ layout.tsx    → 앱 wrapper
```

### 3.2 Next.js App Router 페이지 전환

#### Phase 1: Next.js Link 컴포넌트
```typescript
import Link from 'next/link';

// Next.js Link는 프리페칭과 최적화 제공
<Link href="/about" prefetch={true}>
  Go to About
</Link>
```

**Link 내부 동작:**
1. **Prefetching**: 링크가 뷰포트에 나타나면 미리 로드
2. **Client-side Navigation**: 클릭 시 SPA 방식 전환
3. **History API**: `history.pushState()` 사용

#### Phase 2: Next.js 라우팅 시스템
```typescript
// Next.js 내부 라우터 (simplified)
class NextRouter {
  async navigate(href: string) {
    // 1. 라우트 정보 수집
    const routeInfo = await this.getRouteInfo(href);
    
    // 2. 이전 페이지 언마운트
    this.cleanup();
    
    // 3. 새 페이지 로드 및 마운트  
    await this.renderNewPage(routeInfo);
  }
}
```

#### Phase 3: App Router Layout 시스템
```typescript
// app/layout.tsx (루트 레이아웃)
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html>
      <body>
        <Ssgoi config={ssgoiConfig}>
          {children} {/* 페이지별로 변경됨 */}
        </Ssgoi>
      </body>
    </html>
  );
}

// app/page.tsx (홈 페이지)
export default function HomePage() {
  return (
    <SsgoiTransition id="/">
      <h1>Home Page</h1>
    </SsgoiTransition>
  );
}

// app/about/page.tsx (어바웃 페이지)  
export default function AboutPage() {
  return (
    <SsgoiTransition id="/about">
      <h1>About Page</h1>
    </SsgoiTransition>
  );
}
```

### 3.3 Next.js 전환 과정의 차이점

#### 서버 컴포넌트 고려사항
```typescript
// 서버 컴포넌트 (기본)
export default function ServerPage() {
  // 서버에서 렌더링, 클라이언트로 HTML 전송
  return <div>Server Component</div>;
}

// 클라이언트 컴포넌트 (SSGOI 사용)
'use client';
export default function ClientPage() {
  // 클라이언트에서 렌더링, SSGOI 애니메이션 가능
  return (
    <SsgoiTransition id="/client">
      <div>Client Component</div>
    </SsgoiTransition>
  );
}
```

#### SSGOI를 위한 클라이언트 컴포넌트 필수
```typescript
// app/layout.tsx
'use client'; // 🔥 SSGOI는 클라이언트 컴포넌트 필요!

import { Ssgoi } from '@ssgoi/react';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Ssgoi config={config}>
          {children}
        </Ssgoi>
      </body>
    </html>
  );
}
```

### 3.4 Next.js 페이지 전환 타임라인
```
Time: 0ms
├─ 사용자 Next Link 클릭
├─ Next.js prefetch 확인 (이미 로드됨)
├─ Next.js 라우터 URL 변경

Time: ~1ms
├─ 이전 페이지 컴포넌트 언마운트
├─ ref cleanup → SSGOI OUT 🔥
├─ useLayoutEffect cleanup
├─ useEffect cleanup

Time: ~2ms
├─ Next.js 새 페이지 컴포넌트 결정
├─ 새 페이지 렌더링 시작 (클라이언트)
├─ 또는 prefetch된 HTML 사용

Time: ~3ms
├─ 새 페이지 DOM 마운트
├─ ref callback → SSGOI IN 🔥
├─ SSGOI 애니메이션 시작

Time: ~300ms
├─ 애니메이션 완료
```

## 4. SSGOI 개입 시점 상세 분석

### 4.1 ref cleanup이 최우선인 이유

React의 언마운트 순서:
```typescript
function Component() {
  const refCallback = (element) => {
    if (element) {
      console.log('Mount: ref callback');
      return () => {
        console.log('Unmount: ref cleanup'); // 🥇 1순위
      };
    }
  };

  useLayoutEffect(() => {
    console.log('Mount: useLayoutEffect');
    return () => {
      console.log('Unmount: useLayoutEffect cleanup'); // 🥈 2순위
    };
  });

  useEffect(() => {
    console.log('Mount: useEffect');
    return () => {
      console.log('Unmount: useEffect cleanup'); // 🥉 3순위
    };
  });

  return <div ref={refCallback}>Content</div>;
}
```

**왜 ref cleanup이 가장 먼저인가?**
- React는 DOM 요소 제거 전에 ref를 먼저 정리
- 이때 DOM 요소는 아직 완전히 살아있음
- SSGOI가 `cloneNode()`로 복제하기 최적의 타이밍

### 4.2 SSGOI의 타이밍 활용 전략

```typescript
// packages/core/src/lib/create-transition-callback.ts
return (element: HTMLElement | null) => {
  if (!element) return;
  
  // 1. 부모 정보 저장 (복제본 삽입용)
  parentRef = element.parentElement;
  nextSiblingRef = element.nextElementSibling;

  // 2. IN 애니메이션 준비
  runEntrance(element);

  // 3. cleanup 함수 반환 (React가 언마운트 시 호출)
  return () => {
    // 🔥 ref cleanup 시점 - DOM 요소 아직 살아있음!
    const cloned = element.cloneNode(true) as HTMLElement;
    runExitTransition(cloned);
  };
};
```

## 5. 라이프사이클 Hook들의 한계와 SSGOI의 우위

### 5.1 useEffect cleanup의 한계
```typescript
function MyPage() {
  useEffect(() => {
    return () => {
      // ❌ 이 시점에는 이미 DOM 요소가 제거됨
      // ❌ 애니메이션 불가능
      console.log('useEffect cleanup - 너무 늦음');
    };
  }, []);

  return <div>Page Content</div>;
}
```

### 5.2 useLayoutEffect cleanup의 한계
```typescript
function MyPage() {
  useLayoutEffect(() => {
    return () => {
      // ⚠️ DOM 요소는 있지만 React가 이미 제거 예약
      // ⚠️ 복제해도 부모 정보가 부정확할 수 있음
      console.log('useLayoutEffect cleanup - 애매한 타이밍');
    };
  }, []);

  return <div>Page Content</div>;
}
```

### 5.3 ref callback의 우위
```typescript
function MyPage() {
  const refCallback = (element) => {
    if (element) {
      return () => {
        // ✅ DOM 요소 완전히 살아있음
        // ✅ 부모/형제 정보 정확
        // ✅ 완벽한 복제 가능
        console.log('ref cleanup - 완벽한 타이밍!');
      };
    }
  };

  return <div ref={refCallback}>Page Content</div>;
}
```

## 6. 실제 프로젝트에서의 적용

### 6.1 Next.js App Router + SSGOI 설정
```typescript
// app/layout.tsx
'use client';
import { Ssgoi } from '@ssgoi/react';
import { fade } from '@ssgoi/react/view-transitions';

const config = {
  defaultTransition: fade(),
  transitions: [
    {
      from: '/',
      to: '/about',
      transition: fade(),
      symmetric: true,
    },
  ],
};

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Ssgoi config={config}>
          {children}
        </Ssgoi>
      </body>
    </html>
  );
}
```

### 6.2 페이지 컴포넌트
```typescript
// app/page.tsx
'use client';
import { SsgoiTransition } from '@ssgoi/react';

export default function HomePage() {
  return (
    <SsgoiTransition id="/">
      <div>
        <h1>Home Page</h1>
        <Link href="/about">Go to About</Link>
      </div>
    </SsgoiTransition>
  );
}

// app/about/page.tsx  
'use client';
import { SsgoiTransition } from '@ssgoi/react';

export default function AboutPage() {
  return (
    <SsgoiTransition id="/about">
      <div>
        <h1>About Page</h1>
        <Link href="/">Go to Home</Link>
      </div>
    </SsgoiTransition>
  );
}
```

## 7. 성능 최적화 관점

### 7.1 Next.js Prefetching과 SSGOI
```typescript
// Link prefetch와 SSGOI 조합
<Link href="/about" prefetch={true}>
  {/* Next.js가 미리 로드 → 빠른 전환 + SSGOI 애니메이션 */}
  Go to About
</Link>
```

**장점:**
- Next.js: 빠른 페이지 로드
- SSGOI: 부드러운 애니메이션
- 결합: 속도 + UX 모두 확보

### 7.2 메모리 사용 최적화
```typescript
// SSGOI의 메모리 관리
onComplete: () => {
  if (currentClone) {
    currentClone.remove(); // DOM 정리
    currentClone = null;   // 메모리 정리
  }
  currentAnimation = null; // 상태 정리
}
```

## 8. 결론

### 8.1 React/Next.js 페이지 전환의 특징
- **즉시성**: 브라우저 새로고침 없는 빠른 전환
- **한계**: 갑작스러운 화면 변화로 인한 UX 저하

### 8.2 SSGOI의 해결책
- **타이밍**: ref cleanup 시점의 완벽한 활용
- **복제**: 사라지는 요소의 완전한 보존
- **동기화**: OUT/IN 애니메이션의 조화로운 실행

### 8.3 최종 결과
Next.js와 SSGOI를 함께 사용하면:
- ✅ Next.js의 빠른 라우팅
- ✅ SSGOI의 부드러운 애니메이션  
- ✅ 네이티브 앱 수준의 사용자 경험

**핵심**: React의 라이프사이클을 정확히 이해하고 최적의 시점(ref cleanup)에 개입하여 한계를 극복한 것이 SSGOI의 성공 비결입니다.