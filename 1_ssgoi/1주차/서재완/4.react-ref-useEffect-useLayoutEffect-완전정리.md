# React ref, useEffect, useLayoutEffect 완전 정리

## 개요

React에서 ref callback, useEffect, useLayoutEffect의 동작 원리와 각각의 용도, 실행 타이밍, 그리고 언제 어떤 것을 사용해야 하는지 완전 정리합니다.

## 1. ref callback 완전 이해

### 1.1 ref callback이란?

ref callback은 React에서 DOM 요소에 접근하는 방법 중 하나입니다.

```typescript
// 방법 1: useRef 사용
const elementRef = useRef<HTMLDivElement>(null);
<div ref={elementRef}>Content</div>

// 방법 2: ref callback 사용 (더 강력함)
const refCallback = (element: HTMLDivElement | null) => {
  if (element) {
    console.log('요소가 마운트됨:', element);
    // cleanup 함수 반환 가능!
    return () => {
      console.log('요소가 언마운트됨:', element);
    };
  }
};
<div ref={refCallback}>Content</div>
```

### 1.2 ref callback의 실행 타이밍

```typescript
function MyComponent() {
  console.log('1. 컴포넌트 렌더링');

  const refCallback = (element: HTMLDivElement | null) => {
    if (element) {
      console.log('3. ref callback 실행 (마운트)');
      return () => {
        console.log('6. ref callback cleanup (언마운트)');
      };
    } else {
      console.log('언마운트 시 null로 호출됨');
    }
  };

  useLayoutEffect(() => {
    console.log('4. useLayoutEffect 실행');
    return () => {
      console.log('7. useLayoutEffect cleanup');
    };
  }, []);

  useEffect(() => {
    console.log('5. useEffect 실행');
    return () => {
      console.log('8. useEffect cleanup');
    };
  }, []);

  console.log('2. JSX 반환 직전');
  return <div ref={refCallback}>Content</div>;
}
```

**실행 순서:**
```
마운트:
1. 컴포넌트 렌더링
2. JSX 반환 직전
3. ref callback 실행 (마운트)
4. useLayoutEffect 실행
5. useEffect 실행

언마운트:
6. ref callback cleanup (언마운트) ← 🔥 가장 먼저!
7. useLayoutEffect cleanup
8. useEffect cleanup
```

### 1.3 ref callback cleanup이 하는 일

```typescript
const refCallback = (element: HTMLDivElement | null) => {
  if (element) {
    // 마운트 시 수행할 작업
    console.log('DOM 요소 마운트:', element);
    
    // 이벤트 리스너 등록
    const handleClick = () => console.log('clicked');
    element.addEventListener('click', handleClick);
    
    // DOM 조작
    element.style.opacity = '1';
    
    // cleanup 함수 반환
    return () => {
      // 🔥 언마운트 시 정리 작업
      console.log('DOM 요소 언마운트 준비:', element);
      
      // 이벤트 리스너 제거
      element.removeEventListener('click', handleClick);
      
      // SSGOI처럼 요소 복제도 가능!
      const clone = element.cloneNode(true);
      
      // DOM 조작 정리
      element.style.opacity = '0';
    };
  }
};
```

**ref callback cleanup의 특징:**
- DOM 요소가 **완전히 살아있는 상태**에서 실행
- 부모, 형제 요소 정보 모두 접근 가능
- 완벽한 DOM 조작 및 복제 가능
- React가 실제로 DOM에서 제거하기 직전 타이밍

## 2. useEffect 완전 이해

### 2.1 useEffect의 특징

```typescript
function MyComponent() {
  useEffect(() => {
    console.log('useEffect 실행');
    
    // 🔥 비동기적으로 실행됨 (브라우저 페인트 후)
    // 화면 렌더링을 블록하지 않음
    
    return () => {
      console.log('useEffect cleanup');
    };
  }, []); // 의존성 배열

  return <div>Content</div>;
}
```

### 2.2 useEffect가 적합한 작업들

#### 2.2.1 데이터 페칭 (Data Fetching)
```typescript
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // ✅ 데이터 페칭은 useEffect가 최적
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData);
    }

    fetchUser();
  }, [userId]); // userId 변경 시 재실행

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

#### 2.2.2 구독 (Subscriptions)
```typescript
function ChatComponent() {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // ✅ 외부 시스템 구독
    const unsubscribe = chatService.subscribe((newMessage) => {
      setMessages(prev => [...prev, newMessage]);
    });

    return () => {
      // ✅ 구독 해제
      unsubscribe();
    };
  }, []);

  return (
    <div>
      {messages.map(msg => <div key={msg.id}>{msg.text}</div>)}
    </div>
  );
}
```

#### 2.2.3 타이머 관리
```typescript
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // ✅ 타이머 시작
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    return () => {
      // ✅ 타이머 정리
      clearInterval(interval);
    };
  }, []);

  return <div>Count: {count}</div>;
}
```

#### 2.2.4 이벤트 리스너 (전역)
```typescript
function KeyboardHandler() {
  useEffect(() => {
    // ✅ 전역 이벤트 리스너
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        // ESC 키 처리
      }
    };

    window.addEventListener('keydown', handleKeyDown);

    return () => {
      // ✅ 이벤트 리스너 제거
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  return <div>Press ESC to close</div>;
}
```

#### 2.2.5 상태 동기화
```typescript
function LocalStorageSync({ value }: { value: string }) {
  useEffect(() => {
    // ✅ 로컬 스토리지와 동기화
    localStorage.setItem('myValue', value);
  }, [value]); // value 변경시마다 저장

  return <div>{value}</div>;
}
```

### 2.3 useEffect cleanup 패턴

```typescript
function MyComponent() {
  useEffect(() => {
    // 설정 작업
    const controller = new AbortController();
    const eventSource = new EventSource('/api/events');
    const interval = setInterval(() => {}, 1000);

    // 여러 정리 작업
    return () => {
      controller.abort();      // API 요청 취소
      eventSource.close();     // EventSource 종료
      clearInterval(interval); // 타이머 정리
    };
  }, []);
}
```

## 3. useLayoutEffect 완전 이해

### 3.1 useLayoutEffect의 특징

```typescript
function MyComponent() {
  useLayoutEffect(() => {
    console.log('useLayoutEffect 실행');
    
    // 🔥 동기적으로 실행됨 (브라우저 페인트 전)
    // 화면 렌더링을 블록할 수 있음
    // DOM 변경이 화면에 반영되기 전에 실행
    
    return () => {
      console.log('useLayoutEffect cleanup');
    };
  }, []);

  return <div>Content</div>;
}
```

### 3.2 useLayoutEffect만 할 수 있는 작업들

#### 3.2.1 DOM 측정 및 즉시 스타일 적용
```typescript
function AutoSizeTextarea() {
  const [text, setText] = useState('');
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useLayoutEffect(() => {
    // ✅ DOM 측정 후 즉시 스타일 적용 (깜빡임 방지)
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [text]); // text 변경시마다 높이 조정

  return (
    <textarea
      ref={textareaRef}
      value={text}
      onChange={(e) => setText(e.target.value)}
      style={{ resize: 'none', overflow: 'hidden' }}
    />
  );
}
```

#### 3.2.2 스크롤 위치 복원
```typescript
function ScrollRestoration() {
  const [items, setItems] = useState([]);
  const listRef = useRef<HTMLDivElement>(null);
  const savedScrollTop = useRef(0);

  useLayoutEffect(() => {
    // ✅ 새 아이템 로드 후 스크롤 위치 즉시 복원
    if (listRef.current) {
      listRef.current.scrollTop = savedScrollTop.current;
    }
  }, [items]);

  const handleScroll = () => {
    if (listRef.current) {
      savedScrollTop.current = listRef.current.scrollTop;
    }
  };

  return (
    <div ref={listRef} onScroll={handleScroll}>
      {items.map(item => <div key={item.id}>{item.name}</div>)}
    </div>
  );
}
```

#### 3.2.3 애니메이션 시작 전 스타일 설정
```typescript
function AnimatedModal({ isOpen }: { isOpen: boolean }) {
  const modalRef = useRef<HTMLDivElement>(null);

  useLayoutEffect(() => {
    if (modalRef.current && isOpen) {
      // ✅ 애니메이션 시작 전 초기 상태 설정 (깜빡임 방지)
      modalRef.current.style.opacity = '0';
      modalRef.current.style.transform = 'scale(0.8)';
      
      // 다음 프레임에서 애니메이션 시작
      requestAnimationFrame(() => {
        if (modalRef.current) {
          modalRef.current.style.transition = 'all 0.3s ease';
          modalRef.current.style.opacity = '1';
          modalRef.current.style.transform = 'scale(1)';
        }
      });
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div ref={modalRef} className="modal">
      Modal Content
    </div>
  );
}
```

#### 3.2.4 Tooltip 위치 계산
```typescript
function Tooltip({ targetRef, children }: {
  targetRef: RefObject<HTMLElement>;
  children: ReactNode;
}) {
  const tooltipRef = useRef<HTMLDivElement>(null);
  const [position, setPosition] = useState({ top: 0, left: 0 });

  useLayoutEffect(() => {
    // ✅ DOM 측정 후 즉시 위치 계산 (깜빡임 방지)
    if (targetRef.current && tooltipRef.current) {
      const targetRect = targetRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current.getBoundingClientRect();
      
      const top = targetRect.bottom + 8;
      const left = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
      
      setPosition({ top, left });
    }
  });

  return (
    <div
      ref={tooltipRef}
      style={{
        position: 'fixed',
        top: position.top,
        left: position.left,
        zIndex: 1000,
      }}
    >
      {children}
    </div>
  );
}
```

#### 3.2.5 Virtual Scrolling 구현
```typescript
function VirtualList({ items }: { items: any[] }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });

  useLayoutEffect(() => {
    // ✅ 스크롤 후 즉시 가시 범위 계산
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      const scrollTop = container.scrollTop;
      const itemHeight = 50; // 고정 높이
      const containerHeight = container.clientHeight;
      
      const start = Math.floor(scrollTop / itemHeight);
      const end = Math.min(start + Math.ceil(containerHeight / itemHeight) + 1, items.length);
      
      setVisibleRange({ start, end });
    };

    container.addEventListener('scroll', handleScroll);
    handleScroll(); // 초기 계산

    return () => container.removeEventListener('scroll', handleScroll);
  }, [items]);

  const visibleItems = items.slice(visibleRange.start, visibleRange.end);

  return (
    <div ref={containerRef} style={{ height: 400, overflow: 'auto' }}>
      <div style={{ height: items.length * 50 }}>
        <div style={{ transform: `translateY(${visibleRange.start * 50}px)` }}>
          {visibleItems.map((item, index) => (
            <div key={visibleRange.start + index} style={{ height: 50 }}>
              {item.name}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 3.3 useLayoutEffect 주의사항

```typescript
function BadExample() {
  const [data, setData] = useState(null);

  useLayoutEffect(() => {
    // ❌ 비동기 작업을 useLayoutEffect에서 하면 안됨!
    // 브라우저 렌더링을 블록함
    fetch('/api/data')
      .then(response => response.json())
      .then(setData);
  }, []);

  return <div>{data?.name}</div>;
}

function GoodExample() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // ✅ 비동기 작업은 useEffect에서
    fetch('/api/data')
      .then(response => response.json())
      .then(setData);
  }, []);

  return <div>{data?.name}</div>;
}
```

## 4. 언제 무엇을 사용할까?

### 4.1 선택 기준

| 작업 유형 | ref callback | useEffect | useLayoutEffect |
|----------|-------------|-----------|-----------------|
| DOM 요소 접근/조작 | ✅ 최적 | ⚠️ 제한적 | ✅ 가능 |
| 요소 생성/제거 감지 | ✅ 완벽 | ❌ 불가 | ❌ 불가 |
| 데이터 페칭 | ❌ 부적절 | ✅ 최적 | ❌ 부적절 |
| DOM 측정 | ✅ 가능 | ⚠️ 깜빡임 | ✅ 완벽 |
| 애니메이션 준비 | ✅ 완벽 | ⚠️ 깜빡임 | ✅ 완벽 |
| 이벤트 리스너 | ✅ 요소별 | ✅ 전역 | ✅ 전역 |
| 구독/타이머 | ❌ 부적절 | ✅ 최적 | ⚠️ 성능 문제 |

### 4.2 실제 사용 패턴

#### 4.2.1 SSGOI 같은 애니메이션 라이브러리
```typescript
// ✅ ref callback 사용 - 완벽한 타이밍
const refCallback = (element: HTMLElement | null) => {
  if (element) {
    // 입장 애니메이션 준비
    runEntranceAnimation(element);
    
    return () => {
      // 완벽한 시점에 요소 복제 및 퇴장 애니메이션
      const clone = element.cloneNode(true);
      runExitAnimation(clone);
    };
  }
};
```

#### 4.2.2 반응형 컴포넌트
```typescript
function ResponsiveComponent() {
  const elementRef = useRef<HTMLDivElement>(null);
  const [isMobile, setIsMobile] = useState(false);

  useLayoutEffect(() => {
    // ✅ 화면 크기에 따른 즉시 스타일 적용
    const checkMobile = () => {
      if (elementRef.current) {
        const width = elementRef.current.offsetWidth;
        setIsMobile(width < 768);
      }
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  });

  return (
    <div ref={elementRef}>
      {isMobile ? <MobileLayout /> : <DesktopLayout />}
    </div>
  );
}
```

#### 4.2.3 데이터 동기화 컴포넌트
```typescript
function DataSync({ userId }: { userId: string }) {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // ✅ 데이터 페칭은 useEffect
    let cancelled = false;

    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        if (!cancelled) {
          setUserData(data);
        }
      } catch (error) {
        if (!cancelled) {
          console.error('Failed to fetch user:', error);
        }
      }
    }

    fetchUser();

    return () => {
      cancelled = true; // cleanup으로 취소 처리
    };
  }, [userId]);

  return userData ? <UserProfile data={userData} /> : <Loading />;
}
```

## 5. 고급 패턴과 조합

### 5.1 ref callback + useLayoutEffect 조합
```typescript
function MeasuredComponent() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const elementRef = useRef<HTMLDivElement>(null);

  const refCallback = (element: HTMLDivElement | null) => {
    elementRef.current = element;
    if (element) {
      // 초기 측정
      const rect = element.getBoundingClientRect();
      setDimensions({ width: rect.width, height: rect.height });
    }
  };

  useLayoutEffect(() => {
    // 크기 변경 감지
    if (!elementRef.current) return;

    const resizeObserver = new ResizeObserver(entries => {
      for (const entry of entries) {
        setDimensions({
          width: entry.contentRect.width,
          height: entry.contentRect.height,
        });
      }
    });

    resizeObserver.observe(elementRef.current);
    return () => resizeObserver.disconnect();
  });

  return (
    <div ref={refCallback}>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}
```

### 5.2 useEffect + useLayoutEffect 조합
```typescript
function OptimizedComponent({ data }: { data: any[] }) {
  const [processedData, setProcessedData] = useState([]);
  const listRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // ✅ 무거운 데이터 처리는 useEffect (비동기)
    const processed = data.map(item => ({
      ...item,
      computed: expensiveComputation(item),
    }));
    setProcessedData(processed);
  }, [data]);

  useLayoutEffect(() => {
    // ✅ DOM 조작은 useLayoutEffect (동기)
    if (listRef.current && processedData.length > 0) {
      // 스크롤 위치 조정 등
      listRef.current.scrollTop = 0;
    }
  }, [processedData]);

  return (
    <div ref={listRef}>
      {processedData.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

## 6. 성능 최적화 팁

### 6.1 ref callback 최적화
```typescript
function OptimizedRef() {
  // ✅ useCallback으로 ref callback 메모이제이션
  const refCallback = useCallback((element: HTMLDivElement | null) => {
    if (element) {
      // 초기화 로직
      return () => {
        // 정리 로직
      };
    }
  }, []); // 의존성 없음

  return <div ref={refCallback}>Content</div>;
}
```

### 6.2 useLayoutEffect 성능 주의
```typescript
function PerformanceAware() {
  const [trigger, setTrigger] = useState(0);

  useLayoutEffect(() => {
    // ❌ 매번 실행되면 성능 문제
    console.log('매번 실행됨');
  }); // 의존성 배열 없음

  useLayoutEffect(() => {
    // ✅ 필요할 때만 실행
    console.log('trigger 변경시에만 실행');
  }, [trigger]); // 의존성 배열 있음

  return <button onClick={() => setTrigger(prev => prev + 1)}>Trigger</button>;
}
```

## 7. 결론

### 7.1 각각의 최적 용도

**ref callback:**
- DOM 요소의 생성/제거 감지
- 완벽한 타이밍의 DOM 조작
- 애니메이션 라이브러리 구현
- 요소별 이벤트 리스너 관리

**useEffect:**
- 데이터 페칭
- 외부 시스템 구독
- 타이머 관리
- 전역 이벤트 리스너
- 상태 동기화

**useLayoutEffect:**
- DOM 측정 및 즉시 스타일 적용
- 애니메이션 초기 상태 설정
- 스크롤 위치 조작
- 깜빡임 방지가 중요한 UI 조작

### 7.2 SSGOI가 ref callback을 선택한 이유

1. **완벽한 타이밍**: DOM 요소가 완전히 살아있는 마지막 순간
2. **완전한 접근**: 부모, 형제 요소 정보 모두 접근 가능
3. **자연스러운 정리**: React의 정리 과정과 완벽히 조화
4. **성능 최적화**: 필요한 순간에만 실행

**핵심**: 각 Hook의 특성을 정확히 이해하고 용도에 맞게 사용하는 것이 React 개발의 핵심입니다.