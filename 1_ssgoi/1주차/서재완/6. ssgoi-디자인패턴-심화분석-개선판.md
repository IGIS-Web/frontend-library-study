# SSGOI 디자인 패턴 심화 분석: 왜 이 패턴들을 선택했을까?

## 들어가며

이 문서는 SSGOI 프로젝트에서 사용된 디자인 패턴들을 **실제 문제 상황**과 함께 분석합니다. 단순히 "이 패턴이 좋다"가 아니라, **어떤 구체적인 문제를 해결하기 위해** 이 패턴을 선택했는지, 그리고 **다른 방법들과 비교했을 때 왜 더 나은지**를 상세히 설명합니다.

---

## 📋 패턴별 핵심 목적 요약

각 디자인 패턴이 SSGOI에서 해결하는 핵심 문제들을 미리 살펴보세요:

### 🏭 **Factory Pattern**
객체 생성 시 복잡한 초기화 로직을 캡슐화하여 안전하고 일관된 인스턴스 생성을 보장합니다.
- **해결 문제**: 애니메이션 상태 복원 시 복잡한 타입별 초기화 로직
- **핵심 가치**: 타입 안전성, 시간적 결합 제거, 유효성 검증 자동화

### 🎯 **Strategy Pattern**  
런타임에 알고리즘을 교체할 수 있게 하여 복잡한 조건부 로직을 체계적으로 관리합니다.
- **해결 문제**: 4가지 애니메이션 시나리오의 복잡한 분기 로직
- **핵심 가치**: 코드 분리, 테스트 용이성, 새로운 시나리오 추가 시 기존 코드 무변경

### 👀 **Observer Pattern**
객체 간의 느슨한 결합을 유지하면서 상태 변화를 여러 객체에 알릴 수 있게 합니다.
- **해결 문제**: 애니메이션 진행 상태를 여러 요소가 동시에 관찰해야 하는 상황
- **핵심 가치**: Promise 기반 동기화, 동적 관찰자 추가/제거, 메모리 누수 방지

### 🎭 **Facade Pattern**
복잡한 하위 시스템을 간단한 인터페이스로 감싸서 사용자의 학습 비용을 줄입니다.
- **해결 문제**: Core 패키지의 200+ 줄 복잡 로직을 React 개발자가 쉽게 사용
- **핵심 가치**: 학습 곡선 감소, 실수 방지, 프레임워크별 최적화

### 🔧 **Builder Pattern**
복잡한 객체의 구성을 단계별로 처리하여 설정의 유연성과 가독성을 높입니다.
- **해결 문제**: 20+ 개 전환의 각기 다른 복잡한 옵션 조합 관리
- **핵심 가치**: 매개변수 순서 독립성, 점진적 설정 구성, 타입 안전성

### 🎮 **Command Pattern**
요청을 객체로 캡슐화하여 실행 취소, 재실행, 히스토리 관리를 가능하게 합니다.
- **해결 문제**: 애니메이션 제어 명령의 복잡한 상태 의존성과 조건부 실행
- **핵심 가치**: 명령 히스토리, 실행 취소 기능, 디버깅 지원

### 🗂️ **Registry Pattern**
전역 상태를 안전하게 관리하고 중복 생성을 방지하여 메모리 효율성을 높입니다.
- **해결 문제**: 같은 전환이 여러 곳에서 사용될 때의 메모리 중복과 상태 불일치
- **핵심 가치**: 메모리 효율성, 안전한 중복 체크, 전역 상태 모니터링

### 🔄 **State Pattern**
객체의 상태를 명시적으로 관리하여 상태별 행동을 체계적으로 제어합니다.
- **해결 문제**: 애니메이션의 복잡한 상태 조합과 전환 시나리오 관리
- **핵심 가치**: 상태 전환 검증, 예상치 못한 상태 조합 방지, 디버깅 용이성

### 📋 **Template Method Pattern**
공통 알고리즘 구조를 정의하고 세부사항만 하위 클래스에서 구현하게 하여 코드 재사용성을 극대화합니다.
- **해결 문제**: 20+ 개 전환의 공통 구조 코드 중복과 일관성 유지
- **핵심 가치**: 전역 기능 추가 시 한 곳 수정, 버그 수정 전파, Hook 메서드 지원

### 🔌 **Adapter Pattern**
호환되지 않는 인터페이스들을 연결하여 기존 코드의 재사용성을 높입니다.
- **해결 문제**: Core 패키지와 React/Vue/Svelte 등 프레임워크별 다른 인터페이스 연결
- **핵심 가치**: 프레임워크 독립성, 인터페이스 변환, 에러 처리 표준화

---

## 1. Factory Pattern: `Animator.fromState()` - 왜 정말 필요했을까?

### 🤔 의문: "그냥 new Animator()면 안 되나?"

이런 의문이 들 수 있습니다:
```typescript
// 이게 복잡하다고?
const animator = new Animator(options);
animator.setValue(currentState.position);
animator.setVelocity(currentState.velocity);

// 이게 더 간단하다고?  
const animator = Animator.fromState(currentState, options);
```

**맞습니다.** 단순히 이 두 줄만 보면 첫 번째도 충분히 간단해 보입니다.

### 💡 하지만 실제 SSGOI 상황을 보면...

실제 SSGOI 코드에서 애니메이터 생성이 필요한 상황들을 살펴보겠습니다:

#### 상황 1: 애니메이션 중단 후 새로운 애니메이션 시작
```typescript
// packages/core/src/lib/transition-strategy.ts:69
if (currentAnimation && currentAnimation.direction === "out") {
  // 현재 실행 중인 OUT 애니메이션을 중단하고 IN 애니메이션으로 전환
  const currentState = currentAnimation.animator.getCurrentState();
  currentAnimation.animator.stop();

  // ❌ Factory 없이 직접 생성한다면...
  const newAnimator = new Animator({
    from: 0,  // ← 어? IN 애니메이션은 0부터 시작인가?
    to: 1,    // ← 아니면 1부터?
    spring: outConfig.spring, // ← OUT config를 써야 하나 IN config를 써야 하나?
    onUpdate: outConfig.tick, // ← 이것도 OUT꺼를 써야 하나?
    onComplete: () => {
      currentAnimation = null;
      // ← 정리 로직을 매번 작성해야 함
    }
  });
  
  // 현재 상태를 설정해야 하는데...
  newAnimator.setValue(currentState.position); // ← 이게 맞나?
  newAnimator.setVelocity(currentState.velocity); // ← 이건?
  
  // 방향을 역전시켜야 하는데...
  newAnimator.reverse(); // ← 이걸 호출해야 하나? 안 해야 하나?

  // ✅ Factory 사용
  const newAnimator = Animator.fromState(currentState, {
    from: outConfig.from ?? 1,
    to: outConfig.to ?? 0, 
    spring: outConfig.spring,
    onUpdate: outConfig.tick,
    onComplete: () => {
      currentAnimation = null;
      outConfig.onEnd?.();
    }
  });
  // 끝! 모든 복잡한 로직이 팩토리 안에 캡슐화됨
}
```

#### 상황 2: 타입별로 다른 초기화 로직
```typescript
// 실제 SSGOI에서 애니메이션 값 타입에 따른 초기화
function createAnimator<T>(animationType: 'number' | 'object', initialState: any) {
  // ❌ Factory 없이 직접 생성한다면...
  if (animationType === 'number') {
    const animator = new Animator({
      from: 0,
      to: 1,
      spring: { stiffness: 300, damping: 30 },
      onUpdate: (value: number) => {
        // number 타입 처리
      }
    });
    animator.setValue(initialState.position);
    animator.setVelocity(initialState.velocity);
  } else if (animationType === 'object') {
    const animator = new Animator({
      from: { x: 0, y: 0, scale: 0 },
      to: { x: 1, y: 1, scale: 1 },
      spring: { stiffness: 300, damping: 30 },
      onUpdate: (value: Record<string, number>) => {
        // object 타입 처리
      }
    });
    // 객체 타입은 속도 설정이 다름!
    animator.setValue(initialState.position);
    // velocity도 객체 형태로 설정해야 함
    animator.setVelocity({
      x: initialState.velocity.x || 0,
      y: initialState.velocity.y || 0, 
      scale: initialState.velocity.scale || 0
    });
  }
  
  // ✅ Factory 사용
  const animator = Animator.fromState(initialState, options);
  // 타입에 따른 모든 복잡한 초기화 로직이 팩토리 내부에서 처리됨
}
```

### 🔍 실제 Factory가 해결하는 구체적 문제들

#### 1. **시간적 결합(Temporal Coupling) 문제**
```typescript
// ❌ 순서를 잘못하면 버그!
const animator = new Animator(options);
animator.setVelocity(velocity); // ← 먼저 velocity를 설정하고
animator.setValue(position);    // ← 그 다음 position을 설정해야 함
// 순서가 바뀌면 velocity 계산이 잘못됨!

// ✅ Factory는 순서 문제 없음
const animator = Animator.fromState({ position, velocity }, options);
```

#### 2. **타입 안전성 문제**
```typescript
// ❌ 컴파일 타임에 잡히지 않는 오류들
const animator = new Animator<number>(options);
animator.setValue({ x: 10, y: 20 }); // ← 타입 오류! 하지만 실행 시점에야 발견
animator.setVelocity([1, 2, 3]);     // ← 이것도 타입 오류!

// ✅ Factory는 타입 체크 강화
const animator = Animator.fromState<number>(
  { position: 10, velocity: 5 }, // ← 타입이 맞지 않으면 컴파일 에러
  options
);
```

#### 3. **복잡한 유효성 검증**
```typescript
// ❌ 매번 유효성 검증을 직접 해야 함
const animator = new Animator(options);
if (typeof position === 'number' && position >= 0 && position <= 1) {
  animator.setValue(position);
} else {
  throw new Error('Invalid position');
}
if (typeof velocity === 'number' && !isNaN(velocity)) {
  animator.setVelocity(velocity);
} else {
  animator.setVelocity(0);
}

// ✅ Factory 내부에서 모든 검증 처리
const animator = Animator.fromState(state, options);
// 내부에서 모든 유효성 검증과 기본값 설정 완료
```

#### 4. **메모리 누수 방지**
```typescript
// ❌ cleanup 로직을 깜빡하기 쉬움
const animator = new Animator({
  onUpdate: (value) => element.style.opacity = value.toString(),
  onComplete: () => {
    // cleanup 로직을 매번 작성해야 함
    currentAnimation = null;
    // ← 다른 정리 로직들을 깜빡할 수 있음
  }
});

// ✅ Factory에서 표준화된 cleanup 제공
const animator = Animator.fromState(state, {
  onUpdate: (value) => element.style.opacity = value.toString(),
  // onComplete는 Factory에서 자동으로 적절한 cleanup 포함하여 생성
});
```

### 🤔 "그런데... 복잡한 로직은 결국 어딘가에 작성해야 하는 거 아닌가?"

이 질문은 Factory Pattern을 처음 배울 때 많은 개발자들이 가지는 핵심적인 의문입니다.

**맞습니다.** Factory 내부에는 결국 복잡한 초기화 로직을 작성해야 합니다:

```typescript
// ❌ "Factory 없이 직접 작성하는 것"
const newAnimator = new Animator({
  from: outConfig.from ?? 1,
  to: outConfig.to ?? 0, 
  spring: outConfig.spring,
  onUpdate: outConfig.tick,
  onComplete: () => {
    currentAnimation = null;
    outConfig.onEnd?.();
  }
});

// ✅ "Factory 사용하는 것"  
const newAnimator = Animator.fromState(currentState, {
  from: outConfig.from ?? 1,
  to: outConfig.to ?? 0, 
  spring: outConfig.spring,
  onUpdate: outConfig.tick,
  onComplete: () => {
    currentAnimation = null;
    outConfig.onEnd?.();
  }
});
```

**"이 두 개가 뭐가 다르지?"** 라고 생각할 수 있습니다. 하지만...

### 🎯 Factory Pattern의 진짜 가치: "Write Once, Use Everywhere"

Factory의 핵심은 **복잡성을 한 곳에 모으고, 단순함을 여러 곳에 퍼뜨리는 것**입니다.

#### 실제 SSGOI 규모에서의 차이

SSGOI에서 애니메이터 생성이 필요한 곳들:
- **20개 전환 타입** (fade, slide, scale, rotate, bounce...)
- **각 전환의 in/out** (40개 생성 지점)  
- **4가지 시나리오별 처리** (일반 IN, 일반 OUT, IN→OUT 역전, OUT→IN 역전)

**총 160개 생성 지점**에서 애니메이터를 만들어야 합니다.

```typescript
// ❌ Factory 없다면: 160곳에서 이런 복잡한 로직을 반복
function createFadeTransition(state) {
  const animator = new Animator({...});
  
  // 타입별 초기화 로직 (20줄)
  if (typeof state.position === 'number') {
    animator.setValue(state.position);
    animator.setVelocity(state.velocity);
  } else if (Array.isArray(state.position)) {
    // 배열 타입 처리 (10줄)
  } else if (typeof state.position === 'object') {
    // 객체 타입 처리 (15줄)
    animator.setVelocity({
      x: state.velocity.x || 0,
      y: state.velocity.y || 0,
      scale: state.velocity.scale || 0
    });
  }
  
  // 유효성 검증 (15줄)
  // 기본값 설정 (10줄)  
  // 에러 처리 (15줄)
  // 메모리 누수 방지 (10줄)
}

function createSlideTransition(state) {
  // 😰 똑같은 85줄이 또 반복됨!
}

function createScaleTransition(state) {
  // 😰 또 똑같은 85줄!
}

// ... 157개 더
// 총 160 × 85줄 = 13,600줄의 중복 코드!
```

```typescript
// ✅ Factory 사용: 160곳에서 간단히 호출, 복잡한 로직은 한 곳에만
const fadeAnimator = Animator.fromState(state, fadeOptions);    // 1줄
const slideAnimator = Animator.fromState(state, slideOptions);  // 1줄  
const scaleAnimator = Animator.fromState(state, scaleOptions);  // 1줄
// ... 157개 더 (각각 1줄)

// Factory 내부에만 85줄의 복잡한 로직 존재
// 총 160줄 + 85줄 = 245줄
```

**13,600줄 vs 245줄** - 이게 Factory Pattern의 진짜 위력입니다!

#### 유지보수의 극적인 차이

```typescript
// 🐛 버그 발견: velocity 설정에서 메모리 누수가 발생함!

// ❌ Factory 없다면
// - 160개 파일을 모두 찾아서 수정해야 함
// - 하나라도 놓치면 버그 지속
// - 각 파일마다 미묘하게 다른 구현으로 인한 추가 버그 가능성

// ✅ Factory 사용
// - Factory 내부 1곳만 수정
// - 160개 생성 지점 모두 자동으로 버그 수정됨
// - 일관된 동작 보장
```

### 🔍 실제 Factory가 해결하는 구체적 문제들

Factory 패턴이 진가를 발휘하는 것은 **복잡한 조건부 로직**과 **여러 단계의 초기화**가 **여러 곳에서 반복**될 때입니다:

```typescript
// packages/core/src/lib/animator.ts:374 - 실제 Factory 구현
static fromState<TAnimationValue = number>(
  state: {
    position: TAnimationValue;
    velocity: TAnimationValue extends number ? number : Record<string, number>;
  },
  newOptions: Partial<AnimationOptions<TAnimationValue>>
): Animator<TAnimationValue> {
  const animation = new Animator<TAnimationValue>(newOptions);
  
  // 🎯 이 85줄의 복잡한 로직이 한 곳에만 존재!
  // 1. 타입에 따른 안전한 값 설정
  animation.setValue(state.position);
  animation.setVelocity(state.velocity);
  
  // 2. 내부 상태 일관성 보장
  // 3. 메모리 누수 방지를 위한 기본 핸들러 설정
  // 4. 타입별 최적화 로직 적용
  
  return animation;
}
```

**Factory Pattern의 본질**: "코드를 안 쓰게 해주는" 패턴이 아니라, **"중복 코드를 제거하고 복잡성을 중앙화하는"** 패턴입니다. 전체 코드베이스 차원에서 봤을 때 엄청난 차이가 납니다.

---

## 2. Strategy Pattern: 4가지 애니메이션 시나리오 - 왜 if-else로 하면 안 될까?

### 🤔 의문: "간단한 if-else면 안 되나?"

```typescript
// 이게 뭐가 복잡하다고?
function handleTransition(direction: 'in' | 'out', hasCurrentAnimation: boolean) {
  if (direction === 'in') {
    if (hasCurrentAnimation) {
      // 시나리오 4: 현재 OUT 애니메이션을 역전
    } else {
      // 시나리오 1: 일반 IN 애니메이션  
    }
  } else {
    if (hasCurrentAnimation) {
      // 시나리오 3: 현재 IN 애니메이션을 역전
    } else {
      // 시나리오 2: 일반 OUT 애니메이션
    }
  }
}
```

이 정도는 충분히 간단해 보입니다. **하지만...**

### 💥 실제 SSGOI의 복잡한 현실

실제 transition-strategy.ts를 보면 각 시나리오가 얼마나 복잡한지 알 수 있습니다:

#### 시나리오 4: OUT 애니메이션 실행 중 + IN 트리거 상황
```typescript
// packages/core/src/lib/transition-strategy.ts:69
if (currentAnimation && currentAnimation.direction === "out") {
  // 1. 현재 애니메이션 상태 캡처
  const currentState = currentAnimation.animator.getCurrentState();
  
  // 2. 안전한 애니메이션 정지
  currentAnimation.animator.stop();

  // 3. OUT 설정을 가져와서 역방향으로 사용
  if (configs.out) {
    const outConfig = await configs.out;
    const { from = 1 as TAnimationValue, to = 0 as TAnimationValue } = outConfig;
    
    return {
      config: outConfig,
      state: currentState,
      from, // OUT의 from을 그대로 사용
      to,   // OUT의 to를 그대로 사용  
      direction: "backward", // 하지만 방향은 역방향!
    };
  }
}
```

#### ❌ 만약 이걸 if-else로 한 함수에 다 넣는다면?
```typescript
function handleAllTransitions(
  direction: 'in' | 'out', 
  configs: any, 
  currentAnimation: any
) {
  if (direction === 'in') {
    if (currentAnimation && currentAnimation.direction === "out") {
      // 시나리오 4 처리
      const currentState = currentAnimation.animator.getCurrentState();
      currentAnimation.animator.stop();
      
      if (configs.out) {
        const outConfig = await configs.out; // ← await!
        const { from = 1, to = 0 } = outConfig;
        return {
          config: outConfig,
          state: currentState,
          from,
          to,
          direction: "backward",
        };
      } else {
        // outConfig가 없는 경우 처리
        return {
          state: { position: 0, velocity: 0 },
          from: 0,
          to: 1,
          direction: "forward",
        };
      }
    } else if (currentAnimation && currentAnimation.direction === "in") {
      // 이미 IN 애니메이션 중인 경우?
      if (configs.in) {
        const inConfig = await configs.in;
        // 기존 애니메이션 계속? 재시작? 
        // 복잡한 로직...
      }
    } else {
      // 시나리오 1: 일반 IN
      const config = await configs.in;
      if (!config) {
        return {
          state: { position: 0, velocity: 0 },
          from: 0,
          to: 1,
          direction: "forward",
        };
      }
      const { from = 0, to = 1 } = config;
      return {
        config,
        state: { position: from, velocity: 0 },
        from,
        to,
        direction: "forward",
      };
    }
  } else if (direction === 'out') {
    if (currentAnimation && currentAnimation.direction === "in") {
      // 시나리오 3 처리
      const currentState = currentAnimation.animator.getCurrentState();
      currentAnimation.animator.stop();
      
      if (configs.in) {
        const inConfig = await configs.in;
        const { from = 0, to = 1 } = inConfig;
        return {
          config: inConfig,
          state: {
            position: currentState.position,
            velocity: currentState.velocity,
          },
          from,
          to,
          direction: "backward",
        };
      }
    } else if (currentAnimation && currentAnimation.direction === "out") {
      // 이미 OUT 애니메이션 중인 경우?  
      // 또 다른 복잡한 분기...
    } else {
      // 시나리오 2: 일반 OUT
      const config = await configs.out;
      if (!config) {
        return {
          state: { position: 1, velocity: 0 },
          from: 1,
          to: 0,
          direction: "forward",
        };
      }
      const { from = 1, to = 0 } = config;
      return {
        config,
        state: { position: from, velocity: 0 },
        from,
        to,
        direction: "forward",
      };
    }
  }
  
  // 😵 이 함수는 이미 100줄이 넘었고, 
  // 새로운 케이스가 생기면 더 복잡해질 예정...
}
```

### 🛡️ Strategy Pattern이 해결하는 문제들

#### 1. **async/await 로직의 분리**
각 시나리오마다 다른 async 처리 로직이 필요한데, 이를 하나의 함수에 넣으면 가독성이 크게 떨어집니다.

#### 2. **새로운 시나리오 추가 시의 영향도**
만약 "애니메이션 일시정지 후 재개" 같은 새로운 시나리오가 생긴다면?

```typescript
// ❌ if-else 방식: 기존 함수를 수정해야 함
function handleAllTransitions() {
  if (direction === 'in') {
    if (currentAnimation && currentAnimation.direction === "out") {
      // 기존 로직
    } else if (currentAnimation && currentAnimation.direction === "paused") {
      // 🆕 새로운 분기 추가 - 기존 코드 수정!
    } else {
      // 기존 로직
    }
  }
  // 😰 기존 코드가 점점 복잡해짐
}

// ✅ Strategy 방식: 새로운 전략만 추가
const pauseResumeStrategy = {
  runIn: async (configs) => {
    // 일시정지 상태에서의 IN 처리만 구현
  },
  runOut: async (configs) => {
    // 일시정지 상태에서의 OUT 처리만 구현  
  }
};
// 기존 코드는 전혀 건드리지 않음!
```

#### 3. **테스트의 복잡성**
```typescript
// ❌ 하나의 큰 함수: 모든 시나리오를 한번에 테스트
test('handleAllTransitions', () => {
  // 시나리오 1 테스트
  // 시나리오 2 테스트  
  // 시나리오 3 테스트
  // 시나리오 4 테스트
  // 😵 테스트 코드가 수백 줄...
});

// ✅ Strategy 패턴: 각 전략별로 독립 테스트
test('runIn - scenario 4', () => {
  // 시나리오 4의 IN 처리만 테스트
});

test('runOut - scenario 3', () => {
  // 시나리오 3의 OUT 처리만 테스트
});
```

---

## 3. Observer Pattern: 왜 직접 호출하면 안 될까?

### 🤔 의문: "그냥 함수 직접 호출하면 안 되나?"

```typescript
// 이게 뭐가 나쁘다고?
function updateAnimation(progress: number) {
  element.style.opacity = progress.toString();
  console.log('Progress:', progress);
  updateProgressBar(progress);
}
```

간단해 보이지만, 실제 SSGOI에서는 훨씬 복잡한 상황들이 있습니다.

### 🔄 실제 SSGOI의 복잡한 애니메이션 생명주기

#### 상황 1: 여러 요소가 동시에 같은 애니메이션을 관찰해야 하는 경우
```typescript
// hero transition에서: 여러 요소가 동시에 애니메이션됨
// packages/core/src/lib/view-transitions/hero.ts:143
tick: (progress) => {
  heroAnimations.forEach(({ toEl, dx, dy, dw, dh }) => {
    toEl.style.transform = `translate(${(1 - progress) * dx}px,${(1 - progress) * dy}px) scale(${progress + (1 - progress) * dw}, ${progress + (1 - progress) * dh})`;
  });
},
```

#### ❌ Observer 없이 직접 호출한다면?
```typescript
function updateHeroAnimation(progress: number) {
  // 요소 1 업데이트
  element1.style.transform = `translate(${progress * 100}px, 0)`;
  
  // 요소 2 업데이트  
  element2.style.transform = `scale(${progress})`;
  
  // 요소 3 업데이트
  element3.style.opacity = progress.toString();
  
  // 로깅
  console.log('Hero animation progress:', progress);
  
  // 진행률 표시
  updateProgressIndicator(progress);
  
  // 성능 추적
  trackPerformance('hero-animation', progress);
  
  // 😱 새로운 요소가 추가되면? 이 함수를 수정해야 함!
  // 😱 로깅을 제거하고 싶으면? 이 함수를 수정해야 함!
  // 😱 다른 애니메이션에서도 같은 로깅이 필요하면? 코드 복사해야 함!
}
```

#### ✅ Observer 패턴 사용
```typescript
// 각 관찰자가 독립적으로 등록됨
animator.onUpdate = (progress) => {
  // 각 요소가 자신의 업데이트 로직만 처리
  heroAnimations.forEach(({ toEl, dx, dy, dw, dh }) => {
    toEl.style.transform = `...`;
  });
};

// 새로운 관찰자 추가가 쉬움
animator.addObserver('logger', (progress) => {
  console.log('Progress:', progress);
});

animator.addObserver('performance', (progress) => {
  trackPerformance('animation', progress);
});

// 특정 관찰자만 제거도 쉬움
animator.removeObserver('logger');
```

### 🎭 Observer Pattern의 진짜 위력: Promise 기반 동기화

SSGOI의 가장 복잡한 부분 중 하나는 **OUT과 IN 애니메이션의 동기화**입니다:

```typescript
// packages/core/src/lib/create-ssgoi-transition-context.ts:182
return new Promise<GetTransitionConfig>(resolve => {
  pendingTransition!.outResolve = resolve; // 🔔 Observer 등록
  checkAndResolve(); // 조건 확인 후 알림
});
```

#### ❌ Observer 없이 직접 처리한다면?
```typescript
let outAnimationReady = false;
let inAnimationReady = false;
let outConfig: any = null;
let inConfig: any = null;

function handleOutAnimation(path: string) {
  // OUT 애니메이션 준비
  outConfig = getOutConfig(path);
  outAnimationReady = true;
  
  // IN도 준비되었는지 확인해야 함
  if (inAnimationReady) {
    startBothAnimations(outConfig, inConfig);
  }
  // 😰 상태 관리가 복잡해짐
}

function handleInAnimation(path: string) {
  // IN 애니메이션 준비
  inConfig = getInConfig(path);
  inAnimationReady = true;
  
  // OUT도 준비되었는지 확인해야 함  
  if (outAnimationReady) {
    startBothAnimations(outConfig, inConfig);
  }
  // 😰 중복 로직
}

// 😱 타이밍 문제: IN이 먼저 호출되면? OUT이 먼저 호출되면?
// 😱 에러 처리: 하나가 실패하면 어떻게 정리할까?
// 😱 타임아웃: 하나가 영원히 오지 않으면?
```

#### ✅ Observer + Promise 패턴
```typescript
const getTransition = async (path: string, type: "out" | "in") => {
  return new Promise<GetTransitionConfig>(resolve => {
    if (type === "out") {
      pendingTransition!.outResolve = resolve;
    } else {
      pendingTransition!.inResolve = resolve;
    }
    checkAndResolve(); // 둘 다 준비되면 자동으로 해결
  });
};

function checkAndResolve() {
  if (pendingTransition?.from && pendingTransition?.to) {
    // 🎯 둘 다 준비되면 자동으로 Observer들에게 알림
    const transition = findMatchingTransition(/* ... */);
    
    if (pendingTransition.outResolve) {
      pendingTransition.outResolve(/* OUT config */);
    }
    if (pendingTransition.inResolve) {
      pendingTransition.inResolve(/* IN config */);
    }
    
    pendingTransition = null; // 자동 정리
  }
}
```

---

## 4. Facade Pattern: React 개발자가 Core의 복잡함을 몰라도 되는 이유

### 🎭 실제로 Facade가 숨기는 복잡함들

#### React 개발자가 보는 것:
```typescript
function App() {
  return (
    <Ssgoi config={{ defaultTransition: fade() }}>
      <Router>
        <Routes>
          <Route path="/" element={
            <SsgoiTransition id="/">
              <HomePage />
            </SsgoiTransition>
          } />
        </Routes>
      </Router>
    </Ssgoi>
  );
}
```

**"이게 뭐가 복잡하다고?"** 맞습니다. 사용하는 입장에서는 정말 간단합니다.

#### 하지만 Facade 없이 직접 Core를 사용한다면:
```typescript
function App() {
  // 1. 대칭 전환 처리
  const processedTransitions = useMemo(() => {
    const transitions = config.transitions || [];
    const reversedTransitions = transitions
      .filter(t => t.symmetric)
      .map(t => ({
        from: t.to,
        to: t.from,
        transition: t.transition
      }));
    return [...transitions, ...reversedTransitions];
  }, [config.transitions]);

  // 2. 스크롤 매니저 설정
  const scrollManager = useMemo(() => {
    let scrollContainer: HTMLElement | null = null;
    const scrollPositions: Map<string, {x: number; y: number}> = new Map();
    let currentPath: string | null = null;

    const scrollListener = () => {
      if (scrollContainer && currentPath) {
        scrollPositions.set(currentPath, {
          x: scrollContainer.scrollLeft,
          y: scrollContainer.scrollTop
        });
      }
    };

    return {
      startScrollTracking: (element: HTMLElement, path: string) => {
        if (!scrollContainer) {
          scrollContainer = getScrollingElement(element);
          const target = scrollContainer === document.documentElement ? window : scrollContainer;
          target.addEventListener("scroll", scrollListener, { passive: true });
        }
        currentPath = path;
      },
      calculateScrollOffset: (from?: string, to?: string) => {
        const fromScroll = from && scrollPositions.has(from) ? scrollPositions.get(from)! : {x: 0, y: 0};
        const toScroll = to && scrollPositions.has(to) ? scrollPositions.get(to)! : {x: 0, y: 0};
        return {
          x: -toScroll.x + fromScroll.x,
          y: -toScroll.y + fromScroll.y
        };
      }
    };
  }, []);

  // 3. Pending Transition 관리
  const [pendingTransition, setPendingTransition] = useState<any>(null);

  // 4. 전환 매칭 로직
  const findMatchingTransition = useCallback((from: string, to: string) => {
    for (const config of processedTransitions) {
      if (matchPath(from, config.from) && matchPath(to, config.to)) {
        return config.transition;
      }
    }
    for (const config of processedTransitions) {
      if ((config.from === "*" || matchPath(from, config.from)) && 
          (config.to === "*" || matchPath(to, config.to))) {
        return config.transition;
      }
    }
    return null;
  }, [processedTransitions]);

  // 5. 전환 컨텍스트 생성
  const transitionContext = useCallback((path: string) => {
    return {
      key: path,
      in: async (element: HTMLElement) => {
        scrollManager.startScrollTracking(element, path);
        
        // getTransition 로직 구현...
        if (!pendingTransition || !pendingTransition.from) {
          return () => ({});
        }

        return new Promise<GetTransitionConfig>(resolve => {
          // Promise 로직 구현...
        });
      },
      out: async (element: HTMLElement) => {
        return new Promise<GetTransitionConfig>(resolve => {
          // 또 다른 복잡한 로직...
        });
      }
    };
  }, [scrollManager, pendingTransition, findMatchingTransition]);

  // 😵 이미 100줄이 넘었고, 에러 처리나 엣지 케이스는 아직 구현도 안 함!

  return (
    <SsgoiContextProvider value={transitionContext}>
      <Router>
        {/* ... */}
      </Router>
    </SsgoiContextProvider>
  );
}
```

### 🎯 Facade의 진정한 가치

1. **학습 곡선 대폭 감소**: React 개발자는 React 패턴만 알면 됨
2. **실수 방지**: 복잡한 초기화 로직을 잘못 구현할 가능성 제거  
3. **업데이트 안정성**: Core 로직이 변경되어도 사용자 코드는 영향 없음
4. **프레임워크별 최적화**: React의 특성에 맞는 최적화 적용

---

## 5. Builder Pattern: 복잡한 설정을 어떻게 우아하게 관리할까?

### 🤔 의문: "객체로 설정 넘기는 거랑 뭐가 달라?"

```typescript
// 이게 Builder 패턴이라고?
const config = {
  transitions: [{
    from: "/",
    to: "/about",
    transition: fade({ spring: { stiffness: 300, damping: 30 } }),
    symmetric: true
  }],
  defaultTransition: fade()
};

// 그냥 객체로 설정 넘기는 거 아닌가?
```

**맞습니다.** 겉보기에는 단순한 설정 객체 같아 보입니다.

### 💡 하지만 SSGOI의 실제 Builder 복잡도를 보면...

#### 상황 1: 전환 설정의 계층적 복잡성
```typescript
// packages/core/src/lib/transitions/slide.ts:13
export const slide = (options: SlideOptions = {}) => {
  const {
    direction,
    distance = 100,
    opacity = 0,
    fade = true,
    axis,
    spring = { stiffness: 400, damping: 35 }
  } = options;

  // ❌ Builder 없이 직접 모든 옵션을 매번 지정한다면...
  const slideTransition = createSlideTransition(
    'left',           // direction
    100,              // distance
    0,                // opacity
    true,             // fade
    undefined,        // axis (direction과 충돌할 수 있음!)
    400,              // spring.stiffness
    35,               // spring.damping
    true,             // includeOpacity
    false,            // reverseDirection
    'px',             // distanceUnit
    // 😵 10개가 넘는 매개변수...
  );

  // ✅ Builder 패턴으로 단계별 구성
  const slideTransition = slide({
    direction: 'left',
    spring: { stiffness: 400, damping: 35 },
    fade: true
    // 나머지는 합리적인 기본값 사용
  });
}
```

#### 상황 2: 옵션 간 의존성과 검증
```typescript
// ❌ Builder 없이 직접 처리한다면...
function createSlideTransition(direction?: string, axis?: string, distance?: number) {
  // 옵션 검증을 매번 해야 함
  if (direction && axis) {
    throw new Error('direction과 axis는 동시에 사용할 수 없습니다');
  }
  
  if (!direction && !axis) {
    direction = 'left'; // 기본값
  }
  
  if (typeof distance === 'string' && !distance.includes('px') && !distance.includes('%')) {
    throw new Error('distance 문자열은 px 또는 % 단위여야 합니다');
  }
  
  // 😰 매번 이런 검증 로직을 반복해야 함
}

// ✅ Builder 내부에서 옵션 검증과 의존성 처리
const getActualDirection = (): 'left' | 'right' | 'up' | 'down' => {
  if (direction) return direction;
  if (axis === 'x') return 'left';
  if (axis === 'y') return 'up';
  return 'left';
};
```

#### 상황 3: 복잡한 기본값 계산
```typescript
// packages/core/src/lib/view-transitions/pinterest.ts:321
export const pinterest = (options: PinterestOptions = {}): SggoiTransition => {
  const spring: SpringConfig = {
    stiffness: options.spring?.stiffness ?? 50,  // Pinterest는 느린 애니메이션
    damping: options.spring?.damping ?? 10,      // 낮은 damping으로 자연스러운 움직임
  };
  const timeout = options.timeout ?? 300;

  // ❌ Builder 없이 직접 계산한다면...
  function createPinterestTransition(springStiffness?: number, springDamping?: number, timeout?: number) {
    // Pinterest 전환의 특성상 다른 기본값이 필요
    const calculatedStiffness = springStiffness ?? (
      // Pinterest는 시각적 무게감이 중요하므로 낮은 stiffness
      50
    );
    const calculatedDamping = springDamping ?? (
      // 자연스러운 감속을 위한 낮은 damping
      10
    );
    const calculatedTimeout = timeout ?? (
      // 복잡한 레이아웃 계산 시간 고려
      300
    );
    // 😰 각 전환마다 이런 계산 로직을 반복해야 함
  }
};
```

### 🔧 Builder Pattern이 해결하는 구체적 문제들

#### 1. **매개변수 순서 의존성 제거**
```typescript
// ❌ 위치 기반 매개변수: 순서를 바꾸면 버그!
const transition1 = createTransition('left', 100, 0.5, true, false);
const transition2 = createTransition('left', 0.5, 100, true, false); // 😱 distance와 opacity 순서 바뀜!

// ✅ Builder: 순서 상관없이 명확한 의미
const transition1 = slide({ direction: 'left', distance: 100, opacity: 0.5 });
const transition2 = slide({ direction: 'left', opacity: 0.5, distance: 100 }); // ✅ 순서 바뀌어도 OK
```

#### 2. **점진적 설정 구성**
```typescript
// ❌ 한 번에 모든 설정을 알아야 함
const complexTransition = createComplexTransition(
  'fade-slide',     // type
  'left',           // direction  
  100,              // distance
  0,                // startOpacity
  1,                // endOpacity
  300,              // stiffness
  30,               // damping
  true,             // includeScale
  1.1,              // scaleAmount
  'ease-out',       // easing
  // 😵 모든 걸 미리 알고 있어야 함
);

// ✅ Builder: 점진적으로 설정 구성
const baseTransition = slide({ direction: 'left' });
const withFade = slide({ 
  ...baseTransition,
  fade: true,
  opacity: 0.5 
});
const final = slide({
  ...withFade,
  spring: { stiffness: 300, damping: 30 }
});
```

#### 3. **타입 안전성과 자동완성**
```typescript
// TypeScript에서 Builder 패턴의 진가
const slideConfig: SlideOptions = {
  direction: 'left',  // 자동완성: 'left' | 'right' | 'up' | 'down'
  distance: 100,      // 타입: number | string
  spring: {
    stiffness: 300,   // 자동완성과 타입 체크
    damping: 30       // 범위 검증 가능
  }
  // axis: 'x'        // ❌ TypeScript가 direction과 충돌 검출!
};
```

---

## 6. Command Pattern: 애니메이션 제어를 어떻게 객체화할까?

### 🤔 의문: "그냥 메서드 호출하면 안 되나?"

```typescript
// 이게 뭐가 복잡하다고?
animator.forward();
animator.backward();
animator.stop();
```

간단해 보이지만, SSGOI에서는 이런 제어 명령들이 훨씬 복잡한 상황에서 사용됩니다.

### 🎮 실제 SSGOI의 복잡한 애니메이션 제어

#### 상황 1: 애니메이션 상태에 따른 조건부 명령 실행
```typescript
// packages/core/src/lib/animator.ts:263
forward(): void {
  this.stop();           // 🎯 먼저 현재 애니메이션 정지
  this.animate(false);   // 🎯 그 다음 forward 애니메이션 시작
}

backward(): void {
  this.stop();           // 🎯 먼저 현재 애니메이션 정지
  this.animate(true);    // 🎯 그 다음 backward 애니메이션 시작  
}

reverse(): void {
  // 🎯 from/to 값을 바꾸고 실행
  const temp = this.options.from;
  this.options.from = this.options.to;
  this.options.to = temp;

  if (this.isAnimating) {
    const wasReversed = this.shouldReverse();
    this.stop();
    this.animate(!wasReversed);
  }
}
```

#### ❌ Command 패턴 없이 직접 제어한다면?
```typescript
function controlAnimation(action: string, animator: Animator) {
  if (action === 'forward') {
    // 현재 상태 확인
    if (animator.isAnimating) {
      animator.stop();
      // cleanup 작업들...
      resetVelocity();
      clearCallbacks();
    }
    // forward 애니메이션 설정
    setAnimationDirection('forward');
    setTargetValues(0, 1);
    startAnimation();
    
  } else if (action === 'backward') {
    // 😰 비슷한 로직 반복
    if (animator.isAnimating) {
      animator.stop();
      // 또 같은 cleanup 작업들...
    }
    setAnimationDirection('backward');
    setTargetValues(1, 0);
    startAnimation();
    
  } else if (action === 'reverse') {
    // 😱 더 복잡한 로직
    const currentFrom = animator.options.from;
    const currentTo = animator.options.to;
    
    // from/to 교환
    animator.options.from = currentTo;
    animator.options.to = currentFrom;
    
    if (animator.isAnimating) {
      const progress = animator.getCurrentProgress();
      const shouldReverse = progress > 0.5;
      
      animator.stop();
      // cleanup...
      
      if (shouldReverse) {
        // 복잡한 역방향 로직
      } else {
        // 복잡한 정방향 로직
      }
    }
  }
  
  // 😵 새로운 명령이 추가되면 이 함수가 더 복잡해짐
}
```

#### ✅ Command 패턴으로 각 명령 캡슐화
```typescript
// 각 명령이 독립적인 객체로 캡슐화
class ForwardCommand {
  execute(animator: Animator) {
    animator.stop();
    animator.animate(false);
  }
}

class BackwardCommand {
  execute(animator: Animator) {
    animator.stop();
    animator.animate(true);
  }
}

class ReverseCommand {
  execute(animator: Animator) {
    // 복잡한 reverse 로직만 집중
    this.swapFromTo(animator);
    if (animator.isAnimating) {
      this.handleRunningAnimation(animator);
    }
  }
  
  private swapFromTo(animator: Animator) { /* ... */ }
  private handleRunningAnimation(animator: Animator) { /* ... */ }
}
```

### 🔄 Command Pattern의 진짜 위력: 실행 취소와 재실행

#### SSGOI에서의 고급 활용: 애니메이션 히스토리
```typescript
// packages/core/src/lib/transition.ts:29
function registerTransition<TAnimationValue = number>(
  key: TransitionKey,
  transition: Transition<undefined, TAnimationValue>
): TransitionCallback {
  // 🎯 전환을 명령으로 등록
  transitionDefinitions.set(key, transition);

  // 🎯 실행 가능한 명령 반환
  return createTransitionCallback(/* ... */);
}

function unregisterTransition(key: TransitionKey): void {
  // 🎯 명령 해제
  transitionDefinitions.delete(key);
  transitionCallbacks.delete(key);
}
```

#### ❌ 명령 히스토리 없이 디버깅한다면?
```typescript
// 애니메이션이 이상하게 동작할 때...
function debugAnimation() {
  // 😱 어떤 명령들이 실행되었는지 알 수 없음
  console.log('Current state:', animator.getCurrentValue());
  // 😱 어떤 순서로 명령이 실행되었는지 추적 불가
  // 😱 문제가 발생한 명령을 특정하기 어려움
}
```

#### ✅ Command 패턴으로 히스토리 관리
```typescript
class AnimationController {
  private commandHistory: Command[] = [];
  
  execute(command: Command) {
    command.execute(this.animator);
    this.commandHistory.push(command); // 🎯 명령 기록
  }
  
  getHistory() {
    return this.commandHistory.map(cmd => cmd.toString());
  }
  
  undo() {
    const lastCommand = this.commandHistory.pop();
    if (lastCommand && lastCommand.undo) {
      lastCommand.undo(this.animator); // 🎯 실행 취소
    }
  }
}
```

---

## 7. Registry Pattern: 전역 상태를 어떻게 안전하게 관리할까?

### 🤔 의문: "전역 변수면 안 되나?"

```typescript
// 이게 뭐가 나쁘다고?
let transitions = {};
let callbacks = {};

function addTransition(key, transition) {
  transitions[key] = transition;
}
```

간단해 보이지만, SSGOI의 실제 상황에서는 이런 단순한 접근이 큰 문제를 일으킵니다.

### 🗂️ SSGOI의 복잡한 전역 상태 관리

#### 상황 1: 동일한 키로 중복 등록되는 경우
```typescript
// packages/core/src/lib/transition.ts:29
function registerTransition<TAnimationValue = number>(
  key: TransitionKey,
  transition: Transition<undefined, TAnimationValue>
): TransitionCallback {
  transitionDefinitions.set(key, transition);

  // 🎯 기존 callback이 있는지 확인
  let callback = transitionCallbacks.get(key);
  if (callback) {
    return callback; // 🔄 기존 것 재사용!
  }

  // 새로 생성
  callback = createTransitionCallback(/* ... */);
  transitionCallbacks.set(key, callback);
  return callback;
}
```

#### ❌ Registry 없이 전역 객체로 관리한다면?
```typescript
let globalTransitions = {};
let globalCallbacks = {};

function addTransition(key: string, transition: any) {
  // 😱 중복 등록 체크를 깜빡할 수 있음
  globalTransitions[key] = transition;
  
  // 😱 callback도 새로 만들어야 하나? 기존 걸 써야 하나?
  if (globalCallbacks[key]) {
    // 기존 callback이 있는데 새로 만들면 메모리 누수!
    console.warn('Callback already exists');
  }
  
  globalCallbacks[key] = createCallback(transition);
}

function removeTransition(key: string) {
  // 😱 정리 순서를 잘못하면 참조 오류!
  delete globalTransitions[key];
  delete globalCallbacks[key];
  // 😱 다른 곳에서 이 callback을 참조하고 있다면?
}

// 😱 여러 컴포넌트에서 동시에 접근하면?
function Component1() {
  addTransition('fade', fadeTransition);
}

function Component2() {
  addTransition('fade', differentFadeTransition); // 😰 덮어써짐!
}
```

#### ✅ Registry 패턴으로 안전한 관리
```typescript
class TransitionRegistry {
  private definitions = new Map<TransitionKey, Transition<any, any>>();
  private callbacks = new Map<TransitionKey, TransitionCallback>();
  
  register(key: TransitionKey, transition: Transition): TransitionCallback {
    // 🛡️ 안전한 중복 체크
    this.definitions.set(key, transition);
    
    // 🔄 기존 callback 재사용 로직
    let callback = this.callbacks.get(key);
    if (callback) {
      return callback;
    }
    
    // 🆕 새 callback 생성 및 등록
    callback = this.createCallback(transition);
    this.callbacks.set(key, callback);
    return callback;
  }
  
  unregister(key: TransitionKey): void {
    // 🛡️ 안전한 정리 순서 보장
    this.definitions.delete(key);
    this.callbacks.delete(key);
  }
  
  get(key: TransitionKey): Transition | undefined {
    return this.definitions.get(key);
  }
  
  // 🔍 디버깅용 메서드
  getAllKeys(): TransitionKey[] {
    return Array.from(this.definitions.keys());
  }
  
  getStats() {
    return {
      definitionsCount: this.definitions.size,
      callbacksCount: this.callbacks.size
    };
  }
}
```

### 💾 Registry Pattern의 메모리 효율성

#### 상황 2: 같은 transition이 여러 곳에서 사용되는 경우
```typescript
// 여러 페이지에서 같은 fade transition 사용
function Page1() {
  // ❌ Registry 없이: 매번 새로 생성
  const fadeTransition = createFadeTransition(); // 메모리 사용 1
  return <div ref={transition(fadeTransition)}>Page 1</div>;
}

function Page2() {
  const fadeTransition = createFadeTransition(); // 메모리 사용 2 (중복!)
  return <div ref={transition(fadeTransition)}>Page 2</div>;
}

function Page3() {
  const fadeTransition = createFadeTransition(); // 메모리 사용 3 (중복!)
  return <div ref={transition(fadeTransition)}>Page 3</div>;
}

// ✅ Registry 사용: 한 번만 생성, 여러 번 재사용
function Page1() {
  return <div ref={transition({ key: 'fade' })}>Page 1</div>; // Registry에서 가져옴
}

function Page2() {
  return <div ref={transition({ key: 'fade' })}>Page 2</div>; // 같은 인스턴스 재사용
}

function Page3() {
  return <div ref={transition({ key: 'fade' })}>Page 3</div>; // 같은 인스턴스 재사용
}
```

### 🔍 Registry Pattern의 디버깅 이점

```typescript
// Registry를 통한 전역 상태 모니터링
function debugTransitions() {
  const registry = getTransitionRegistry();
  
  console.log('등록된 전환들:', registry.getAllKeys());
  console.log('메모리 사용량:', registry.getStats());
  
  // 특정 전환이 등록되어 있는지 확인
  if (!registry.get('fade')) {
    console.warn('fade 전환이 등록되지 않았습니다!');
  }
  
  // 메모리 누수 체크
  const stats = registry.getStats();
  if (stats.definitionsCount !== stats.callbacksCount) {
    console.error('정의와 콜백 수가 일치하지 않습니다. 메모리 누수 가능성!');
  }
}
```

---

## 8. State Pattern: 애니메이션 상태를 어떻게 체계적으로 관리할까?

### 🤔 의문: "boolean 변수들로 상태 관리하면 안 되나?"

```typescript
// 이게 뭐가 복잡하다고?
let isAnimating = false;
let direction = 'in';
let isPaused = false;

function handleAnimation() {
  if (isAnimating && direction === 'in' && !isPaused) {
    // 처리 로직
  }
}
```

간단해 보이지만, SSGOI의 복잡한 애니메이션 시나리오에서는 이런 방식이 큰 문제를 일으킵니다.

### 🏃 SSGOI의 복잡한 애니메이션 상태들

#### 상황 1: 다양한 애니메이션 상태 조합
```typescript
// packages/core/src/lib/animator.ts:21
export class Animator<TAnimationValue = number> {
  private isAnimating = false;     // 🏃 애니메이션 실행 상태
  private currentValue: TAnimationValue;
  private velocity: TAnimationValue extends number ? number : Record<string, number>;
  
  // 🎯 상태에 따른 다른 행동
  forward(): void {
    if (this.isAnimating) {
      this.stop(); // 🛑 실행 중이면 먼저 정지
    }
    this.animate(false);
  }
}
```

#### ❌ boolean 변수들로 상태 관리한다면?
```typescript
let isAnimating = false;
let direction: 'in' | 'out' | null = null;
let isPaused = false;
let isReversed = false;
let isStopping = false;
let hasError = false;

function handleTransition(newDirection: 'in' | 'out') {
  // 😱 상태 조합이 폭발적으로 증가
  if (isAnimating && !isPaused && !isStopping && !hasError) {
    if (direction === 'in' && newDirection === 'out') {
      // 시나리오 3: IN → OUT
      if (!isReversed) {
        // 정방향에서 역방향으로
        isReversed = true;
        // direction은 'in'을 유지? 'out'으로 변경?
      } else {
        // 이미 역방향인데 또 OUT?
        // 😵 어떻게 처리해야 할까?
      }
    } else if (direction === 'out' && newDirection === 'in') {
      // 시나리오 4: OUT → IN
      if (isReversed) {
        // 역방향에서 정방향으로
        isReversed = false;
        // 😰 복잡한 상태 전환 로직
      }
    }
  } else if (isPaused) {
    // 일시정지 중인 경우
    if (newDirection !== direction) {
      // 방향이 바뀌었는데 일시정지 중이면?
      // 😵 예상치 못한 상태 조합
    }
  } else if (isStopping) {
    // 정지 중인 경우
    // 😱 정지 중인데 새로운 애니메이션 요청이 오면?
  }
  
  // 😵 모든 상태 조합을 다 고려하기 불가능!
}
```

#### ✅ State Pattern으로 명확한 상태 관리
```typescript
// packages/core/src/lib/create-transition-callback.ts:17
let currentAnimation: {
  animator: Animator<TAnimationValue>;
  direction: "in" | "out";
} | null = null;

const runEntrance = async (element: HTMLElement) => {
  // 🎭 현재 상태를 확인하고 적절히 처리
  if (currentClone) {
    currentClone.remove(); // 이전 상태 정리
    currentClone = null;
  }
  
  // ... 애니메이션 로직
  
  // 🔄 명확한 상태 전환
  currentAnimation = { animator, direction: "in" };
};

const runExitTransition = async (element: HTMLElement) => {
  // 🔄 명확한 상태 전환
  currentAnimation = { animator, direction: "out" };
  
  // 상태에 따른 cleanup 로직
};
```

### 🔄 State Pattern의 진짜 위력: 상태 전환 검증

#### 복잡한 상태 전환 시나리오
```typescript
// packages/core/src/lib/transition-strategy.ts:69
if (currentAnimation && currentAnimation.direction === "out") {
  // 🎯 명확한 상태 조건: "OUT 애니메이션 실행 중"
  const currentState = currentAnimation.animator.getCurrentState();
  currentAnimation.animator.stop();
  
  // OUT → IN 전환 로직 (시나리오 4)
}
```

#### ❌ 상태 검증 없이 처리한다면?
```typescript
// 😱 예상치 못한 상태에서 애니메이션 시작
function startAnimation() {
  if (someGlobalFlag && anotherFlag && !yetAnotherFlag) {
    // 😰 이 조건이 정말 원하는 상태인지 확실하지 않음
    
    // 애니메이션 시작하는데...
    // 😱 다른 곳에서 someGlobalFlag를 바꾸면?
    // 😱 비동기 처리 중에 상태가 바뀌면?
  }
}

// 😵 상태 불일치로 인한 버그들
// - 애니메이션이 겹쳐서 실행됨
// - 메모리 누수 (이전 애니메이션 정리 안 됨)
// - 예상치 못한 UI 깜빡임
```

#### ✅ State Pattern으로 안전한 상태 전환
```typescript
class AnimationStateMachine {
  private state: 'idle' | 'animating-in' | 'animating-out' | 'paused' = 'idle';
  
  startIn(): boolean {
    // 🛡️ 허용된 상태에서만 전환 가능
    if (this.state === 'idle' || this.state === 'animating-out') {
      this.state = 'animating-in';
      return true;
    }
    return false; // 불가능한 전환
  }
  
  startOut(): boolean {
    if (this.state === 'idle' || this.state === 'animating-in') {
      this.state = 'animating-out';
      return true;
    }
    return false;
  }
  
  stop(): void {
    // 🛡️ 어떤 상태에서든 idle로 전환 가능
    this.state = 'idle';
  }
  
  canStart(direction: 'in' | 'out'): boolean {
    // 🔍 상태 전환 가능성 미리 확인
    if (direction === 'in') {
      return this.state === 'idle' || this.state === 'animating-out';
    } else {
      return this.state === 'idle' || this.state === 'animating-in';
    }
  }
}
```

### 🐛 State Pattern의 디버깅 이점

```typescript
// 상태 기반 디버깅
function debugAnimationState() {
  const currentState = getCurrentAnimationState();
  
  console.log('현재 애니메이션 상태:', {
    isAnimating: currentState?.animator.getIsAnimating(),
    direction: currentState?.direction,
    progress: currentState?.animator.getCurrentValue(),
    velocity: currentState?.animator.getVelocity()
  });
  
  // 🔍 상태별 가능한 동작 표시
  if (currentState?.direction === 'in') {
    console.log('가능한 동작: stop(), startOut()');
  } else if (currentState?.direction === 'out') {
    console.log('가능한 동작: stop(), startIn()');
  } else {
    console.log('가능한 동작: startIn(), startOut()');
  }
}
```

---

## 9. Template Method Pattern: 공통 구조를 어떻게 재사용할까?

### 🤔 의문: "코드 복사가 뭐가 나쁘다고?"

```typescript
// fade 전환
export const fade = (options: FadeOptions = {}) => {
  const spring = { stiffness: 300, damping: 30 };
  return {
    in: (element) => ({ spring, tick: (progress) => element.style.opacity = progress }),
    out: (element) => ({ spring, tick: (progress) => element.style.opacity = progress })
  };
};

// scale 전환  
export const scale = (options: ScaleOptions = {}) => {
  const spring = { stiffness: 300, damping: 30 }; // 똑같은 코드
  return {
    in: (element) => ({ spring, tick: (progress) => element.style.transform = `scale(${progress})` }),
    out: (element) => ({ spring, tick: (progress) => element.style.transform = `scale(${progress})` })
  };
};

// 이 정도 중복은 많지 않지 않나?
```

**2-3개 전환이라면** 정말 문제없어 보입니다. 하지만 SSGOI에는 **20개 이상의 다양한 전환**이 있습니다.

### 🎭 SSGOI의 다양한 전환들과 공통 패턴

#### 상황 1: 모든 전환의 공통 구조
```typescript
// packages/core/src/lib/transitions/
// fade.ts, scale.ts, slide.ts, rotate.ts, bounce.ts, blur.ts, fly.ts...

// ❌ Template Method 없이 모든 전환을 따로 구현한다면?
export const fade = (options: FadeOptions = {}) => {
  // 1. 옵션 처리 (모든 전환에서 반복)
  const {
    opacity = 0,
    spring = { stiffness: 300, damping: 30 }
  } = options;

  return {
    // 2. 공통 구조 (모든 전환에서 반복)
    in: (element: HTMLElement) => ({
      spring,
      prepare: prepareIncoming, // 공통 준비 로직
      tick: (progress: number) => {
        element.style.opacity = (opacity + (1 - opacity) * progress).toString();
      },
      onStart: () => {
        // 공통 시작 로직
        logTransitionStart('fade', 'in');
        updateTransitionStats('fade');
      },
      onEnd: () => {
        // 공통 종료 로직
        cleanupTransition();
        logTransitionEnd('fade', 'in');
      }
    }),
    out: (element: HTMLElement) => ({
      spring,
      prepare: prepareOutgoing, // 공통 준비 로직 (또 반복!)
      tick: (progress: number) => {
        element.style.opacity = (opacity + (1 - opacity) * progress).toString();
      },
      onStart: () => {
        // 공통 시작 로직 (또 반복!)
        logTransitionStart('fade', 'out');
        updateTransitionStats('fade');
      },
      onEnd: () => {
        // 공통 종료 로직 (또 반복!)
        cleanupTransition();
        logTransitionEnd('fade', 'out');
      }
    })
  };
};

export const scale = (options: ScaleOptions = {}) => {
  // 😰 옵션 처리 로직 또 반복
  const {
    start = 0,
    opacity = 0,
    spring = { stiffness: 300, damping: 30 } // 또 반복!
  } = options;

  return {
    in: (element: HTMLElement) => ({
      spring, // 또 반복!
      prepare: prepareIncoming, // 또 반복!
      tick: (progress: number) => {
        const scaleValue = start + (1 - start) * progress;
        element.style.transform = `scale(${scaleValue})`;
        element.style.opacity = (opacity + (1 - opacity) * progress).toString();
      },
      onStart: () => {
        // 😵 공통 로직 또 반복!
        logTransitionStart('scale', 'in');
        updateTransitionStats('scale');
      },
      onEnd: () => {
        // 😵 공통 로직 또 반복!
        cleanupTransition();
        logTransitionEnd('scale', 'in');
      }
    }),
    // 😰 out 도 비슷하게 반복...
  };
};

// 😵 20개 전환에 이런 반복이 있다면?
```

#### ✅ Template Method 패턴 적용
```typescript
// 공통 템플릿 정의
function createTransition<T>(
  name: string,
  options: T,
  customTick: (element: HTMLElement, progress: number, options: T) => void
) {
  // 1. 공통 옵션 처리
  const spring = (options as any).spring ?? { stiffness: 300, damping: 30 };
  
  return {
    // 2. 공통 구조
    in: (element: HTMLElement) => ({
      spring,
      prepare: prepareIncoming,
      tick: (progress: number) => customTick(element, progress, options), // 🎯 변수 부분
      onStart: () => {
        logTransitionStart(name, 'in');
        updateTransitionStats(name);
      },
      onEnd: () => {
        cleanupTransition();
        logTransitionEnd(name, 'in');
      }
    }),
    out: (element: HTMLElement) => ({
      spring,
      prepare: prepareOutgoing,
      tick: (progress: number) => customTick(element, progress, options), // 🎯 변수 부분
      onStart: () => {
        logTransitionStart(name, 'out');
        updateTransitionStats(name);
      },
      onEnd: () => {
        cleanupTransition();
        logTransitionEnd(name, 'out');
      }
    })
  };
}

// 각 전환은 변수 부분만 구현
export const fade = (options: FadeOptions = {}) => {
  return createTransition('fade', options, (element, progress, opts) => {
    const opacity = opts.opacity ?? 0;
    element.style.opacity = (opacity + (1 - opacity) * progress).toString();
  });
};

export const scale = (options: ScaleOptions = {}) => {
  return createTransition('scale', options, (element, progress, opts) => {
    const start = opts.start ?? 0;
    const scaleValue = start + (1 - start) * progress;
    element.style.transform = `scale(${scaleValue})`;
    element.style.opacity = (start + (1 - start) * progress).toString();
  });
};
```

### 🔄 Template Method Pattern의 진짜 위력: 공통 로직 변경

#### 상황 2: 전역적인 기능 추가
```typescript
// 🆕 새로운 요구사항: 모든 애니메이션에 성능 모니터링 추가

// ❌ Template Method 없이: 20개 파일을 모두 수정
export const fade = (options: FadeOptions = {}) => {
  return {
    in: (element: HTMLElement) => ({
      // ...
      onStart: () => {
        logTransitionStart('fade', 'in');
        updateTransitionStats('fade');
        // 🆕 새로 추가해야 하는 코드
        performance.mark('fade-in-start');
        trackUserBehavior('transition', 'fade-in');
      },
      onEnd: () => {
        cleanupTransition();
        logTransitionEnd('fade', 'in');
        // 🆕 새로 추가해야 하는 코드
        performance.mark('fade-in-end');
        measureTransitionPerformance('fade-in');
      }
    })
  };
};

// 😰 scale.ts, slide.ts, rotate.ts... 20개 파일 모두 수정!

// ✅ Template Method 사용: 한 곳만 수정
function createTransition(name, options, customTick) {
  return {
    in: (element) => ({
      // ...
      onStart: () => {
        logTransitionStart(name, 'in');
        updateTransitionStats(name);
        // 🎯 한 곳에서만 추가!
        performance.mark(`${name}-in-start`);
        trackUserBehavior('transition', `${name}-in`);
      },
      onEnd: () => {
        cleanupTransition();
        logTransitionEnd(name, 'in');
        // 🎯 한 곳에서만 추가!
        performance.mark(`${name}-in-end`);
        measureTransitionPerformance(`${name}-in`);
      }
    })
  };
}
// 🎉 20개 전환이 모두 자동으로 업데이트!
```

#### 상황 3: 버그 수정
```typescript
// 🐛 버그 발견: 모든 전환에서 cleanup 로직에 메모리 누수

// ❌ Template Method 없이: 20개 파일 모두 수정
function cleanupTransition() {
  // ❌ 기존 코드 (버그 있음)
  currentAnimation = null; // 메모리 누수 발생!
  
  // ✅ 수정된 코드
  if (currentAnimation) {
    currentAnimation.stop();
    currentAnimation = null;
  }
}

// 😰 fade.ts, scale.ts... 20개 파일의 cleanup 로직을 모두 수정해야 함

// ✅ Template Method 사용: 한 곳만 수정
function createTransition(name, options, customTick) {
  return {
    // ...
    onEnd: () => {
      cleanupTransition(); // 🎯 한 곳에서 수정하면 모두 적용!
      logTransitionEnd(name, 'in');
    }
  };
}
// 🎉 한 번의 수정으로 20개 전환의 버그 모두 해결!
```

### 🔧 Template Method의 유연성: Hook 메서드

#### 선택적 커스터마이제이션
```typescript
// 고급 Template Method: Hook 메서드 제공
function createAdvancedTransition(name, options, hooks) {
  const {
    customTick,
    beforeStart,     // 🪝 Hook: 시작 전 커스텀 로직
    afterEnd,        // 🪝 Hook: 종료 후 커스텀 로직
    customPrepare,   // 🪝 Hook: 커스텀 준비 로직
    shouldAnimate    // 🪝 Hook: 애니메이션 조건적 실행
  } = hooks;

  return {
    in: (element) => ({
      spring: options.spring ?? { stiffness: 300, damping: 30 },
      prepare: (el) => {
        prepareIncoming(el); // 기본 로직
        customPrepare?.(el); // 🪝 커스텀 로직
      },
      tick: (progress) => {
        if (shouldAnimate?.(progress) !== false) { // 🪝 조건적 실행
          customTick(element, progress, options);
        }
      },
      onStart: () => {
        beforeStart?.(element); // 🪝 커스텀 시작 로직
        logTransitionStart(name, 'in'); // 기본 로직
      },
      onEnd: () => {
        cleanupTransition(); // 기본 로직
        afterEnd?.(element); // 🪝 커스텀 종료 로직
      }
    })
  };
}

// 특별한 요구사항이 있는 전환
export const bounceWithSound = (options) => {
  return createAdvancedTransition('bounce-sound', options, {
    customTick: (element, progress, opts) => {
      // 기본 bounce 로직
      const bounceValue = calculateBounce(progress);
      element.style.transform = `scale(${bounceValue})`;
    },
    beforeStart: (element) => {
      // 🎵 커스텀 기능: 소리 재생
      playSound('bounce-start.mp3');
    },
    afterEnd: (element) => {
      // 🎵 커스텀 기능: 소리 재생
      playSound('bounce-end.mp3');
    },
    shouldAnimate: (progress) => {
      // 🎵 커스텀 기능: 성능 모드에서는 비활성화
      return !isPerformanceMode();
    }
  });
};
```

---

## 10. Adapter Pattern: 다른 인터페이스를 어떻게 연결할까?

### 🤔 의문: "인터페이스 맞춰주기만 하면 되는 거 아닌가?"

```typescript
// React에서 Core 사용할 때
// 이거 단순한 래퍼 아닌가?
export const Ssgoi = ({ config, children }) => {
  const contextValue = createSggoiTransitionContext(config);
  return <SsgoiProvider value={contextValue}>{children}</SsgoiProvider>;
};
```

간단해 보이지만, SSGOI에서 Adapter 패턴이 해결하는 문제는 훨씬 복잡합니다.

### 🔌 SSGOI의 복잡한 인터페이스 연결 문제

#### 상황 1: React ref callback vs Core transition callback
```typescript
// Core의 인터페이스
type CoreTransitionCallback = (element: HTMLElement | null) => void | (() => void);

// React ref의 인터페이스  
type ReactRefCallback = (instance: HTMLElement | null) => void;

// ❌ 단순한 연결만 한다면?
function SimpleWrapper({ children, transition }) {
  const refCallback = (element) => {
    if (element) {
      // 😰 Core transition을 어떻게 호출해야 할까?
      const cleanup = transition(element);
      // 😱 cleanup 함수를 언제 호출해야 할까?
      // 😱 React의 언마운트 시점과 어떻게 동기화할까?
    }
  };
  
  return <div ref={refCallback}>{children}</div>;
}
```

#### ✅ Adapter의 정교한 인터페이스 변환
```typescript
// packages/react/src/lib/transition.ts:2
export { transition } from "@ssgoi/core";

// packages/core/src/lib/transition.ts:75
export function transition(options: {
  key: TransitionKey;
  in?: TransitionConfig;
  out?: TransitionConfig;
}): TransitionCallback {
  // 🔄 React ref callback 형태로 돐온 Core callback 반환
  return registerTransition(options.key, {
    in: options.in,
    out: options.out,
  });
}

// 실제 돐오는 인터페이스 변환
function registerTransition(key, transition): TransitionCallback {
  // Core의 복잡한 로직을 React가 이해할 수 있는 형태로 변환
  return createTransitionCallback(
    () => transitionDefinitions.get(key),
    {
      onCleanupEnd: () => unregisterTransition(key)
    }
  );
}
```

#### 상황 2: 프레임워크별 다른 라이프사이클
```typescript
// ❌ Adapter 없이 각 프레임워크마다 다른 방식으로 구현

// React 버전
function ReactTransition({ children, id }) {
  const ref = useRef();
  
  useEffect(() => {
    if (ref.current) {
      // React의 useEffect 라이프사이클 사용
      const cleanup = startTransition(ref.current, id);
      return cleanup; // React의 cleanup
    }
  }, [id]);
  
  return <div ref={ref}>{children}</div>;
}

// Vue 버전
function VueTransition({ children, id }) {
  const element = ref();
  
  onMounted(() => {
    if (element.value) {
      // Vue의 onMounted 라이프사이클 사용
      const cleanup = startTransition(element.value, id);
      onUnmounted(() => {
        cleanup(); // Vue의 cleanup
      });
    }
  });
  
  return h('div', { ref: element }, children);
}

// Svelte 버전
<script>
  let element;
  export let id;
  
  onMount(() => {
    if (element) {
      // Svelte의 onMount 라이프사이클 사용
      const cleanup = startTransition(element, id);
      onDestroy(() => {
        cleanup(); // Svelte의 cleanup
      });
    }
  });
</script>

<div bind:this={element}>
  <slot />
</div>

// 😰 각 프레임워크마다 다른 라이프사이클에 맞춰 구현해야 함
```

#### ✅ Adapter로 통일된 인터페이스 제공
```typescript
// Core에서 통일된 transition 인터페이스 제공
function transition(options): TransitionCallback {
  // 🔄 모든 프레임워크가 사용할 수 있는 통일된 인터페이스
  return (element: HTMLElement | null) => {
    if (!element) return;
    
    // 입장 애니메이션 실행
    runEntrance(element);
    
    // 나가기 애니메이션을 위한 cleanup 함수 반환
    return () => {
      const cloned = element.cloneNode(true);
      runExitTransition(cloned);
    };
  };
}

// React Adapter: Core 인터페이스를 React ref로 연결
function ReactAdapter({ children, id }) {
  return (
    <div ref={transition({ key: id, in: fadeIn, out: fadeOut })}>
      {children}
    </div>
  );
}

// Vue Adapter: 같은 Core 인터페이스를 Vue ref로 연결
function VueAdapter({ children, id }) {
  const transitionRef = transition({ key: id, in: fadeIn, out: fadeOut });
  
  return h('div', {
    ref: (el) => {
      if (el) {
        const cleanup = transitionRef(el);
        // Vue의 언마운트 시 cleanup 호출 등록
        getCurrentInstance()?.scope.stop = cleanup;
      }
    }
  }, children);
}

// 🎉 모든 프레임워크가 같은 Core 로직을 공유!
```

### 💅 Adapter Pattern의 진짜 위력: 인터페이스 변환

#### 상황 3: 비동기 처리 방식 차이
```typescript
// Core에서는 Promise 기반 비동기 처리
const getTransition = async (path: string, type: "out" | "in") => {
  return new Promise<GetTransitionConfig>(resolve => {
    // 복잡한 Promise 동기화 로직
    pendingTransition!.outResolve = resolve;
    checkAndResolve();
  });
};

// ❌ React에서 직접 Promise를 다룬다면?
function ReactComponent({ id }) {
  const [isReady, setIsReady] = useState(false);
  
  useEffect(() => {
    // 😰 React 개발자가 Core의 복잡한 Promise 로직을 이해해야 함
    getTransition(id, 'in').then(transitionConfig => {
      if (transitionConfig) {
        setIsReady(true);
        // 😱 언제 cleanup을 호출해야 할까?
        // 😱 비동기 상태 관리가 복잡해짐
      }
    });
  }, [id]);
  
  return isReady ? <div>Ready</div> : <div>Loading</div>;
}

// ✅ Adapter가 비동기 복잡성을 숨김
function ReactAdapter({ children, id }) {
  // React 개발자는 단순한 ref만 사용하면 됨
  return (
    <div ref={transition({ key: id })}>
      {children}
    </div>
  );
  // 🎉 모든 복잡한 Promise 로직을 Adapter가 처리!
}
```

#### 상황 4: 에러 처리 방식 차이
```typescript
// Core의 에러 처리
function coreTransition() {
  try {
    // 복잡한 비동기 로직
  } catch (error) {
    // Core 스타일 에러 처리
    console.warn(`Transition failed: ${error.message}`);
    return fallbackTransition;
  }
}

// ❌ React에서 직접 에러를 처리한다면?
function ReactComponent() {
  const [error, setError] = useState(null);
  
  useEffect(() => {
    try {
      coreTransition();
    } catch (err) {
      // 😰 React 개발자가 Core의 에러 형식을 알아야 함
      setError(err);
    }
  }, []);
  
  if (error) {
    return <div>Error: {error.message}</div>; // 😱 Core 에러를 React식으로 변환
  }
}

// ✅ Adapter가 에러 처리를 변환
function transition(options) {
  return (element) => {
    try {
      return coreTransition(element, options);
    } catch (coreError) {
      // 🔄 Core 에러를 React에 적합한 형태로 변환
      console.error('SSGOI Transition Error:', coreError.message);
      
      // React 개발자에게 친숙한 형태로 에러 전달
      if (process.env.NODE_ENV === 'development') {
        throw new Error(`SSGOI: Failed to setup transition. ${coreError.message}`);
      }
      
      // 프로덕션에서는 조용히 실패
      return () => {}; // 빈 cleanup 함수
    }
  };
}
```

---

## 11. 패턴 선택의 판단 기준

### ⚖️ 언제 패턴을 사용하고, 언제 사용하지 않을까?

#### Factory Pattern 사용 판단:
```typescript
// ✅ Factory 사용이 좋은 경우
if (생성로직이_복잡하고 && 여러곳에서_사용되고 && 타입별로_다른_초기화가_필요하다면) {
  useFactory();
}

// ❌ Factory가 과한 경우  
if (생성로직이_단순하고 && 한곳에서만_사용된다면) {
  justUseConstructor();
}

// 예시: 간단한 경우
const simpleButton = new Button('Click me'); // ✅ 이걸로 충분

// 예시: 복잡한 경우  
const animator = Animator.fromState(complexState, complexOptions); // ✅ Factory 필요
```

#### Strategy Pattern 사용 판단:
```typescript
// ✅ Strategy 사용이 좋은 경우
if (알고리즘이_3개이상이고 && 런타임에_변경이_필요하고 && 각각이_복잡하다면) {
  useStrategy();
}

// ❌ Strategy가 과한 경우
if (경우의수가_2개이하이고 && 로직이_간단하다면) {
  useSimpleIfElse();
}
```

### 🧭 SSGOI 패턴 선택의 실제 근거

1. **Factory Pattern**: 애니메이션 생성 시 타입별로 다른 복잡한 초기화 로직 필요
2. **Strategy Pattern**: 4가지 애니메이션 시나리오, 각각 50+ 줄의 복잡한 로직
3. **Observer Pattern**: 애니메이션 상태를 여러 곳에서 관찰, 동적 추가/제거 필요
4. **Facade Pattern**: Core의 복잡함(200+ 줄)을 React 개발자에게 숨길 필요

---

## 결론: 패턴은 도구, 문제가 먼저다

### 🎯 핵심 교훈

1. **문제를 먼저 이해하라**: 패턴을 위한 패턴은 독
2. **복잡도의 임계점을 파악하라**: 언제 간단한 방법에서 패턴으로 넘어갈지
3. **팀의 이해도를 고려하라**: 모든 팀원이 이해할 수 있는 수준으로
4. **미래의 확장성을 고려하라**: 하지만 과도한 미래 예측은 금물

### 📚 실무에서의 적용

SSGOI처럼 **복잡한 시스템**을 만들 때는 패턴이 필수지만, **간단한 프로젝트**에서는 오히려 독이 될 수 있습니다. 

**핵심은 현재 문제의 복잡도를 정확히 파악하고, 그에 맞는 수준의 해결책을 선택하는 것입니다.**

---

*"완벽한 코드란 더 이상 추가할 것이 없는 코드가 아니라, 더 이상 제거할 것이 없는 코드다." - Antoine de Saint-Exupéry*