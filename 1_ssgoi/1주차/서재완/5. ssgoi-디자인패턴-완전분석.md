# SSGOI 디자인 패턴 완전 분석: 주니어 개발자를 위한 가이드

## 개요

SSGOI 프로젝트는 복잡한 애니메이션 시스템을 구현하면서도 깔끔하고 확장 가능한 아키텍처를 유지하기 위해 다양한 디자인 패턴을 효과적으로 활용합니다.

## 목차

1. [Factory Pattern (팩토리 패턴)](#1-factory-pattern-팩토리-패턴)
2. [Strategy Pattern (전략 패턴)](#2-strategy-pattern-전략-패턴)
3. [Builder Pattern (빌더 패턴)](#3-builder-pattern-빌더-패턴)
4. [Observer Pattern (옵저버 패턴)](#4-observer-pattern-옵저버-패턴)
5. [Template Method Pattern (템플릿 메서드 패턴)](#5-template-method-pattern-템플릿-메서드-패턴)
6. [Command Pattern (커맨드 패턴)](#6-command-pattern-커맨드-패턴)
7. [Facade Pattern (파사드 패턴)](#7-facade-pattern-파사드-패턴)
8. [Registry Pattern (레지스트리 패턴)](#8-registry-pattern-레지스트리-패턴)
9. [Adapter Pattern (어댑터 패턴)](#9-adapter-pattern-어댑터-패턴)
10. [State Pattern (상태 패턴)](#10-state-pattern-상태-패턴)
11. [기타 패턴들](#11-기타-패턴들)
12. [패턴들의 상호작용](#12-패턴들의-상호작용)
13. [주니어 개발자를 위한 학습 포인트](#13-주니어-개발자를-위한-학습-포인트)

---

## 1. Factory Pattern (팩토리 패턴)

### 🎯 목적

객체 생성 로직을 캡슐화하여 코드의 유연성과 재사용성을 높입니다.

### 📍 SSGOI에서의 구현

#### 1.1 Animator Factory

```typescript
// packages/core/src/lib/animator.ts:374
static fromState<TAnimationValue = number>(
  state: {
    position: TAnimationValue;
    velocity: TAnimationValue extends number ? number : Record<string, number>;
  },
  newOptions: Partial<AnimationOptions<TAnimationValue>>
): Animator<TAnimationValue> {
  const animation = new Animator<TAnimationValue>(newOptions);
  animation.setValue(state.position);
  animation.setVelocity(state.velocity);
  return animation;
}
```

**일반적인 생성 vs Factory 사용:**

```typescript
// ❌ 일반적인 방식 - 복잡하고 실수하기 쉬움
const animator = new Animator(options);
animator.setValue(currentState.position);
animator.setVelocity(currentState.velocity);
if (shouldReverse) {
    animator.reverse();
}

// ✅ Factory 패턴 - 간단하고 안전함
const animator = Animator.fromState(currentState, options);
```

#### 1.2 Transition Context Factory

```typescript
// packages/core/src/lib/create-ssgoi-transition-context.ts:129
export function createSggoiTransitionContext(options: SsgoiConfig): SsgoiContext {
    // 복잡한 초기화 로직을 캡슐화
    const processedTransitions = processSymmetricTransitions(transitions);
    const {startScrollTracking, calculateScrollOffset} = createScrollManager();

    // ... 복잡한 로직

    return (path: string) => ({
        key: path,
        in: async (element: HTMLElement) => {
            /* ... */
        },
        out: async (element: HTMLElement) => {
            /* ... */
        }
    });
}
```

#### 1.3 Transition Factory Functions

```typescript
// packages/core/src/lib/view-transitions/fade.ts:8
export const fade = (options: FadeOptions = {}): SggoiTransition => {
    const spring: SpringConfig = {
        stiffness: options.spring?.stiffness ?? 300,
        damping: options.spring?.damping ?? 30
    };

    return {
        in: element => ({
            spring,
            tick: progress => {
                /* ... */
            }
        }),
        out: element => ({
            spring,
            tick: progress => {
                /* ... */
            }
        })
    };
};
```

### 💰 이점

1. **복잡성 숨김**: 객체 생성의 복잡한 로직을 사용자로부터 숨김
2. **일관성 보장**: 올바른 초기화 상태를 보장
3. **타입 안전성**: TypeScript와 함께 사용시 타입 안전성 제공
4. **테스트 용이성**: Mock 객체 생성이 쉬워짐

### 🚫 사용하지 않았다면?

```typescript
// 😱 팩토리 없이 직접 생성한다면...
const animator = new Animator({
    from: setupPhase1(),
    to: setupPhase2(),
    spring: {stiffness: 300, damping: 30},
    onUpdate: value => {
        // 매번 이 로직을 반복해야 함
        element.style.opacity = value.toString();
    },
    onComplete: () => {
        // 매번 정리 로직을 반복해야 함
        cleanupAnimation();
        resetState();
    }
});

// 상태 설정을 깜빡할 수 있음
// animator.setValue(???) // 어떤 값?
// animator.setVelocity(???) // 또 어떤 값?
```

**문제점:**

- 코드 중복
- 실수 가능성 증가
- 일관성 부족
- 테스트 어려움

---

## 2. Strategy Pattern (전략 패턴)

### 🎯 목적

런타임에 알고리즘을 선택할 수 있도록 알고리즘 군을 정의하고 캡슐화합니다.

### 📍 SSGOI에서의 구현

#### 2.1 Transition Strategy

```typescript
// packages/core/src/lib/transition-strategy.ts:61
export const createDefaultStrategy = <TAnimationValue = number>(context: StrategyContext<TAnimationValue>): TransitionStrategy<TAnimationValue> => {
    return {
        runIn: async (configs: TransitionConfigs<TAnimationValue>) => {
            const {currentAnimation} = context;

            // 4가지 시나리오 처리 전략
            if (currentAnimation && currentAnimation.direction === "out") {
                // Scenario 4: OUT → IN (역방향 전환)
                const currentState = currentAnimation.animator.getCurrentState();
                // ...
            }
            // Scenario 1: 일반 IN 애니메이션
            // ...
        },

        runOut: async (configs: TransitionConfigs<TAnimationValue>) => {
            // Scenario 2, 3 처리
            // ...
        }
    };
};
```

#### 2.2 Animation Strategy Selection

```typescript
// packages/core/src/lib/create-transition-callback.ts:31
const strategy = options?.strategy?.(context) || createDefaultStrategy<TAnimationValue>(context);

// 사용자 정의 전략도 가능
const customStrategy = context => ({
    runIn: async configs => {
        // 커스텀 IN 전략
    },
    runOut: async configs => {
        // 커스텀 OUT 전략
    }
});
```

### 💰 이점

1. **유연성**: 런타임에 전략 변경 가능
2. **확장성**: 새로운 전략을 쉽게 추가
3. **재사용성**: 전략을 다른 컨텍스트에서 재사용
4. **테스트 용이성**: 각 전략을 독립적으로 테스트

### 🚫 사용하지 않았다면?

```typescript
// 😱 모든 로직이 한 곳에 몰려있음
function handleTransition(type: 'in' | 'out', configs: any) {
  if (type === 'in') {
    if (currentAnimation && currentAnimation.direction === "out") {
      // 시나리오 4 로직
      if (/* 조건 1 */) {
        // 케이스 1
      } else if (/* 조건 2 */) {
        // 케이스 2
      } else if (/* 조건 3 */) {
        // 케이스 3
      } // ... 무한 if-else
    } else {
      // 시나리오 1 로직
      if (/* 또 다른 조건들 */) {
        // ...
      }
    }
  } else if (type === 'out') {
    // 또 다른 복잡한 분기들...
  }
  // 😵 유지보수 지옥
}
```

**문제점:**

- 거대한 if-else 블록
- 새로운 전략 추가시 기존 코드 수정 필요
- 테스트 복잡성 증가
- 코드 이해 어려움

---

## 3. Builder Pattern (빌더 패턴)

### 🎯 목적

복잡한 객체를 단계별로 구축할 수 있게 하여 생성 과정을 유연하게 제어합니다.

### 📍 SSGOI에서의 구현

#### 3.1 Transition Configuration Builder

```typescript
// 사용 예시 - 단계별 설정 구축
const ssgoiConfig: SsgoiConfig = {
    transitions: [
        {
            from: "/",
            to: "/about",
            transition: fade({
                spring: {
                    stiffness: 300,
                    damping: 30
                }
            }),
            symmetric: true // 자동으로 역방향 전환도 생성
        },
        {
            from: "/gallery",
            to: "/detail/*",
            transition: pinterest({
                spring: {
                    stiffness: 50,
                    damping: 10
                },
                timeout: 500
            })
        }
    ],
    defaultTransition: fade(),
    middleware: (from, to) => ({from, to})
};
```

#### 3.2 Transition Options Builder

```typescript
// packages/core/src/lib/transitions/slide.ts:13
export const slide = (options: SlideOptions = {}) => {
    const {direction, distance = 100, opacity = 0, fade = true, axis, spring = {stiffness: 400, damping: 35}} = options;

    // 옵션들을 조합하여 복잡한 애니메이션 객체 구축
    return {
        in: element => ({
            spring,
            tick: progress => {
                element.style.transform = getTransform(progress);
                if (fade) {
                    element.style.opacity = (opacity + (1 - opacity) * progress).toString();
                }
            }
        }),
        out: element => ({
            /* ... */
        })
    };
};
```

### 💰 이점

1. **점진적 구축**: 복잡한 설정을 단계별로 구성
2. **기본값 제공**: 합리적인 기본값으로 사용 편의성 향상
3. **옵션 조합**: 다양한 옵션을 유연하게 조합
4. **가독성**: 설정 의도가 명확히 표현됨

### 🚫 사용하지 않았다면?

```typescript
// 😱 모든 옵션을 매번 지정해야 함
const slideTransition = createSlideTransition(
    "left", // direction
    100, // distance
    0, // opacity
    true, // fade
    undefined, // axis
    300, // stiffness
    30, // damping
    true, // includeOpacity
    false // reverseDirection
    // ... 더 많은 매개변수들
);

// 😵 옵션 순서를 기억해야 하고, 실수하기 쉬움
```

**문제점:**

- 긴 매개변수 목록
- 옵션 순서 암기 필요
- 기본값 없어서 항상 모든 값 지정
- 가독성 저하

---

## 4. Observer Pattern (옵저버 패턴)

### 🎯 목적

객체의 상태 변화를 관심 있는 다른 객체들에게 자동으로 알립니다.

### 📍 SSGOI에서의 구현

#### 4.1 Animation Lifecycle Observers

```typescript
// packages/core/src/lib/animator.ts:93
this.controls = animate({
    ...animateOptions,

    onUpdate: (value: TAnimationValue) => {
        // 🔔 상태 변화 알림
        this.currentValue = value;
        this.options.onUpdate(value); // Observer 호출!
    },

    onComplete: () => {
        // 🔔 완료 알림
        this.currentValue = target;
        this.isAnimating = false;
        this.options.onComplete(); // Observer 호출!
    }
});
```

#### 4.2 Transition Lifecycle Observers

```typescript
// packages/core/src/lib/view-transitions/fade.ts:15
return {
    in: element => ({
        spring,
        tick: progress => {
            // 🔔 매 프레임마다 관찰자(DOM)에게 알림
            element.style.opacity = progress.toString();
        },
        onStart: () => {
            // 🔔 시작 알림
            console.log("Fade in started");
        },
        onEnd: () => {
            // 🔔 종료 알림
            console.log("Fade in completed");
        }
    })
};
```

#### 4.3 Promise-based Observers

```typescript
// packages/core/src/lib/create-ssgoi-transition-context.ts:182
return new Promise<GetTransitionConfig>(resolve => {
    pendingTransition!.outResolve = resolve; // 🔔 Observer 등록
    checkAndResolve(); // 조건 확인 후 알림
});
```

### 💰 이점

1. **느슨한 결합**: 객체들이 서로 직접 의존하지 않음
2. **확장성**: 새로운 관찰자를 쉽게 추가
3. **반응성**: 상태 변화에 즉시 반응
4. **재사용성**: 같은 이벤트를 여러 관찰자가 처리

### 🚫 사용하지 않았다면?

```typescript
// 😱 모든 곳에 직접 호출 코드
function animateValue(value: number) {
    // DOM 업데이트를 직접 호출
    element1.style.opacity = value.toString();
    element2.style.transform = `scale(${value})`;

    // 로깅을 직접 호출
    console.log("Animation progress:", value);

    // 상태 업데이트를 직접 호출
    updateProgressBar(value);

    // 통계를 직접 호출
    trackAnimationProgress(value);

    // 😵 새로운 기능 추가시마다 이 함수를 수정해야 함
}
```

**문제점:**

- 강한 결합
- 확장성 부족
- 코드 중복
- 단일 책임 원칙 위배

---

## 5. Template Method Pattern (템플릿 메서드 패턴)

### 🎯 목적

알고리즘의 구조는 유지하면서 특정 단계들을 서브클래스에서 재정의할 수 있게 합니다.

### 📍 SSGOI에서의 구현

#### 5.1 Transition Creation Template

```typescript
// 모든 transition 생성 함수들의 공통 템플릿
const transitionTemplate = (options: any) => {
    // 1. 옵션 처리 (공통)
    const spring = {
        stiffness: options.spring?.stiffness ?? 300,
        damping: options.spring?.damping ?? 30
    };

    // 2. 공통 구조 반환
    return {
        in: element => ({
            spring,
            tick: progress => {
                // 3. 각 전환별로 다른 구현 (Template Method)
                applyInAnimation(element, progress, options);
            }
        }),
        out: element => ({
            spring,
            tick: progress => {
                // 4. 각 전환별로 다른 구현 (Template Method)
                applyOutAnimation(element, progress, options);
            }
        })
    };
};
```

#### 5.2 Fade Implementation

```typescript
// packages/core/src/lib/view-transitions/fade.ts:8
export const fade = (options: FadeOptions = {}) => {
    // 템플릿의 특정 부분만 구현
    const applyAnimation = (progress: number) => {
        element.style.opacity = progress.toString(); // 🎯 fade 특화
    };

    return createTransitionTemplate(options, applyAnimation);
};
```

#### 5.3 Scale Implementation

```typescript
// packages/core/src/lib/transitions/scale.ts:31
export const scale = (options: ScaleOptions = {}) => {
    // 템플릿의 특정 부분만 구현
    const applyAnimation = (progress: number) => {
        const scaleValue = start + (1 - start) * progress;
        element.style.transform = getScaleTransform(scaleValue); // 🎯 scale 특화
        element.style.opacity = (opacity + (1 - opacity) * progress).toString();
    };

    return createTransitionTemplate(options, applyAnimation);
};
```

### 💰 이점

1. **코드 재사용**: 공통 로직을 한 번만 작성
2. **일관성**: 모든 구현체가 같은 인터페이스 보장
3. **확장성**: 새로운 전환 추가가 쉬움
4. **유지보수**: 공통 로직 변경이 한 곳에서만

### 🚫 사용하지 않았다면?

```typescript
// 😱 각 전환마다 모든 로직을 반복
export const fade = (options: FadeOptions = {}) => {
    // 옵션 처리 로직 중복
    const spring = {
        stiffness: options.spring?.stiffness ?? 300,
        damping: options.spring?.damping ?? 30
    };

    // 구조 중복
    return {
        in: element => ({
            spring,
            prepare: prepareIncoming, // 중복
            tick: progress => {
                element.style.opacity = progress.toString();
            },
            onStart: () => {
                /* 공통 로직 중복 */
            },
            onEnd: () => {
                /* 공통 로직 중복 */
            }
        }),
        out: element => ({
            /* 또 중복... */
        })
    };
};

export const scale = (options: ScaleOptions = {}) => {
    // 😵 똑같은 옵션 처리 로직
    const spring = {
        stiffness: options.spring?.stiffness ?? 300,
        damping: options.spring?.damping ?? 30
    };

    // 😵 똑같은 구조
    return {
        in: element => ({
            /* 모든 게 중복... */
        })
    };
};
```

**문제점:**

- 코드 중복
- 일관성 부족
- 유지보수 어려움
- 새로운 전환 추가시 많은 보일러플레이트

---

## 6. Command Pattern (커맨드 패턴)

### 🎯 목적

요청을 객체로 캡슐화하여 요청을 매개변수화하고, 큐에 저장하거나 로깅할 수 있게 합니다.

### 📍 SSGOI에서의 구현

#### 6.1 Transition Commands

```typescript
// packages/core/src/lib/transition.ts:75
export function transition<TAnimationValue = number>(options: {
    key: TransitionKey;
    in?: Transition<undefined, TAnimationValue>["in"];
    out?: Transition<undefined, TAnimationValue>["out"];
}): TransitionCallback {
    // 🎯 애니메이션 명령을 객체로 캡슐화
    return registerTransition(options.key, {
        in: options.in, // IN 명령
        out: options.out // OUT 명령
    });
}
```

#### 6.2 Animation Commands

```typescript
// packages/core/src/lib/animator.ts:263
// 각 애니메이션 동작을 명령으로 캡슐화
forward(): void {
  this.stop();
  this.animate(false); // 🎯 Forward 명령
}

backward(): void {
  this.stop();
  this.animate(true); // 🎯 Backward 명령
}

reverse(): void {
  // 🎯 Reverse 명령 - 방향을 바꾸고 실행
  const temp = this.options.from;
  this.options.from = this.options.to;
  this.options.to = temp;

  if (this.isAnimating) {
    const wasReversed = this.shouldReverse();
    this.stop();
    this.animate(!wasReversed);
  }
}
```

#### 6.3 Transition Registry Commands

```typescript
// packages/core/src/lib/transition.ts:29
function registerTransition<TAnimationValue = number>(key: TransitionKey, transition: Transition<undefined, TAnimationValue>): TransitionCallback {
    // 🎯 등록 명령
    transitionDefinitions.set(key, transition);

    // 🎯 실행 명령 반환
    return createTransitionCallback(/* ... */);
}

function unregisterTransition(key: TransitionKey): void {
    // 🎯 해제 명령
    transitionDefinitions.delete(key);
    transitionCallbacks.delete(key);
}
```

### 💰 이점

1. **실행 지연**: 명령을 나중에 실행할 수 있음
2. **로깅/실행취소**: 명령 히스토리 관리 가능
3. **큐잉**: 명령을 큐에 저장하여 순차 실행
4. **매개변수화**: 같은 명령을 다른 매개변수로 실행

### 🚫 사용하지 않았다면?

```typescript
// 😱 모든 곳에서 직접 호출
function handleUserAction(action: string, element: HTMLElement) {
    if (action === "fadeIn") {
        // 직접 애니메이션 로직 호출
        element.style.opacity = "0";
        let progress = 0;
        const interval = setInterval(() => {
            progress += 0.01;
            element.style.opacity = progress.toString();
            if (progress >= 1) {
                clearInterval(interval);
            }
        }, 16);
    } else if (action === "fadeOut") {
        // 😵 또 다른 직접 호출...
    }

    // 😱 실행 취소? 히스토리? 불가능!
}
```

**문제점:**

- 명령과 실행이 강하게 결합
- 실행 취소 불가능
- 로깅 어려움
- 테스트 복잡

---

## 7. Facade Pattern (파사드 패턴)

### 🎯 목적

복잡한 서브시스템의 인터페이스를 단순화하여 사용하기 쉬운 통합 인터페이스를 제공합니다.

### 📍 SSGOI에서의 구현

#### 7.1 React Facade

```typescript
// packages/react/src/lib/ssgoi.tsx:13
export const Ssgoi: React.FC<SsgoiProps> = ({ config, children }) => {
  // 🎭 복잡한 Core 로직을 간단한 React 인터페이스로 숨김
  const contextValue = useMemo<SsgoiContext>(
    () => createSggoiTransitionContext(config), // 복잡한 Core 생성
    [config]
  );

  return <SsgoiProvider value={contextValue}>{children}</SsgoiProvider>;
};
```

**사용자가 보는 간단한 인터페이스:**

```typescript
// ✅ 간단한 사용법 - Facade 덕분!
function App() {
  return (
    <Ssgoi config={simpleConfig}>
      <MyApp />
    </Ssgoi>
  );
}
```

**Facade가 숨기는 복잡함:**

```typescript
// 😱 Facade 없이 직접 사용한다면...
function App() {
  const processedTransitions = processSymmetricTransitions(config.transitions);
  const scrollManager = createScrollManager();
  const pendingTransition = null;
  const transitionContext = createComplexContext(/* 수많은 매개변수 */);

  return (
    <ComplexProvider
      value={transitionContext}
      scrollManager={scrollManager}
      processedTransitions={processedTransitions}
      /* 더 많은 복잡한 props */
    >
      <MyApp />
    </ComplexProvider>
  );
}
```

#### 7.2 SsgoiTransition Facade

```typescript
// packages/react/src/lib/ssgoi-transition.tsx:7
export const SsgoiTransition = ({children, id}: {children: ReactNode; id: string}) => {
    const getTransition = useSsgoi(); // Core와의 복잡한 연결 숨김

    return (
        <div ref={transition(getTransition(id))} data-ssgoi-transition={id}>
            {children}
        </div>
    );
};
```

### 💰 이점

1. **사용 편의성**: 복잡한 시스템을 간단히 사용
2. **학습 곡선 감소**: 핵심 기능만 노출
3. **유지보수**: 내부 변경이 사용자에게 영향 없음
4. **의존성 감소**: 클라이언트가 서브시스템에 직접 의존하지 않음

### 🚫 사용하지 않았다면?

모든 React 사용자가 SSGOI Core의 복잡한 API를 직접 다뤄야 함:

```typescript
// 😱 모든 사용자가 이런 복잡한 코드를 작성해야 함
function MyComponent() {
  const context = createSggoiTransitionContext({
    transitions: processSymmetricTransitions([/* ... */]),
    defaultTransition: createDefaultTransition(),
    middleware: createMiddleware(),
    scrollManager: createScrollManager()
  });

  const transitionCallback = createTransitionCallback(
    () => context('my-page'),
    {
      strategy: createDefaultStrategy(),
      onCleanupEnd: () => cleanupTransition()
    }
  );

  const refCallback = (element) => {
    if (element) {
      transitionCallback(element);
    }
  };

  return <div ref={refCallback}>Content</div>;
}
```

**문제점:**

- 높은 학습 곡선
- 실수하기 쉬운 복잡한 API
- 라이브러리 업데이트 시 사용자 코드 수정 필요

---

## 8. Registry Pattern (레지스트리 패턴)

### 🎯 목적

전역적으로 접근 가능한 객체들을 중앙에서 관리합니다.

### 📍 SSGOI에서의 구현

#### 8.1 Transition Registry

```typescript
// packages/core/src/lib/transition.ts:19
// 🗂️ 전역 레지스트리
const transitionDefinitions = new Map<TransitionKey, Transition<any, any>>();
const transitionCallbacks = new Map<TransitionKey, TransitionCallback>();

function registerTransition<TAnimationValue = number>(key: TransitionKey, transition: Transition<undefined, TAnimationValue>): TransitionCallback {
    // 🗂️ 레지스트리에 등록
    transitionDefinitions.set(key, transition);

    let callback = transitionCallbacks.get(key);
    if (callback) {
        return callback; // 🔄 이미 등록된 것 재사용
    }

    // 새로 생성하여 등록
    callback = createTransitionCallback(/* ... */);
    transitionCallbacks.set(key, callback);
    return callback;
}
```

#### 8.2 Transition Lookup

```typescript
// 등록된 transition을 키로 찾기
const getTransition = (key: TransitionKey) => {
    const transition = transitionDefinitions.get(key);
    if (!transition) {
        console.warn(`Transition "${String(key)}" not found`);
        return {};
    }
    return transition;
};
```

### 💰 이점

1. **중앙 관리**: 모든 transition을 한 곳에서 관리
2. **재사용**: 같은 transition을 여러 곳에서 재사용
3. **메모리 효율**: 중복 생성 방지
4. **디버깅**: 등록된 모든 transition 추적 가능

### 🚫 사용하지 않았다면?

```typescript
// 😱 각 컴포넌트마다 transition 중복 생성
function Page1() {
  const fadeTransition = createFadeTransition(); // 중복 생성 1
  return <div ref={transition(fadeTransition)}>Page 1</div>;
}

function Page2() {
  const fadeTransition = createFadeTransition(); // 중복 생성 2
  return <div ref={transition(fadeTransition)}>Page 2</div>;
}

function Page3() {
  const fadeTransition = createFadeTransition(); // 중복 생성 3
  return <div ref={transition(fadeTransition)}>Page 3</div>;
}

// 😵 메모리 낭비 + 일관성 부족
```

**문제점:**

- 메모리 낭비
- 중복 생성
- 일관성 부족
- 디버깅 어려움

---

## 9. Adapter Pattern (어댑터 패턴)

### 🎯 목적

호환되지 않는 인터페이스를 가진 클래스들이 함께 동작할 수 있게 합니다.

### 📍 SSGOI에서의 구현

#### 9.1 React Ref Adapter

```typescript
// packages/react/src/lib/transition.ts:2
export { transition } from "@ssgoi/core";

// React ref callback과 Core transition callback 연결
const MyComponent = () => {
  return (
    <div ref={transition({  // 🔌 React ref를 Core transition으로 어댑팅
      key: 'my-transition',
      in: fadeIn,
      out: fadeOut
    })}>
      Content
    </div>
  );
};
```

#### 9.2 Framework Adapter

```typescript
// Core는 프레임워크 무관적 설계
// React 패키지가 Adapter 역할

// Core API (프레임워크 무관)
function coreTransition(options) {
    return (element: HTMLElement | null) => {
        // Core 로직
    };
}

// React Adapter
function reactTransition(options) {
    const coreCallback = coreTransition(options);

    // React ref callback 형태로 어댑팅
    return (element: HTMLElement | null) => {
        return coreCallback(element);
    };
}
```

### 💰 이점

1. **호환성**: 다른 인터페이스들을 연결
2. **재사용**: 기존 코드를 수정 없이 재사용
3. **분리**: 프레임워크별 코드 분리
4. **확장성**: 새로운 프레임워크 지원 용이

### 🚫 사용하지 않았다면?

```typescript
// 😱 각 프레임워크마다 Core 로직을 다시 구현
// React 버전
function reactSsgoi() {
    // React용 애니메이션 로직 구현
    // useEffect, useRef 등 React 특화 코드
}

// Vue 버전
function vueSsgoi() {
    // Vue용 애니메이션 로직 구현
    // ref, onMounted 등 Vue 특화 코드
}

// Svelte 버전
function svelteSsgoi() {
    // Svelte용 애니메이션 로직 구현
    // onMount, bind:this 등 Svelte 특화 코드
}

// 😵 핵심 로직이 중복으로 구현됨
```

**문제점:**

- 코드 중복
- 일관성 부족
- 유지보수 어려움
- 버그 수정시 모든 프레임워크 코드 수정 필요

---

## 10. State Pattern (상태 패턴)

### 🎯 목적

객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다.

### 📍 SSGOI에서의 구현

#### 10.1 Animator State Management

```typescript
// packages/core/src/lib/animator.ts:21
export class Animator<TAnimationValue = number> {
    private isAnimating = false; // 🏃 상태
    private currentValue: TAnimationValue;
    private velocity: TAnimationValue extends number ? number : Record<string, number>;

    // 상태에 따른 다른 행동
    forward(): void {
        if (this.isAnimating) {
            this.stop(); // 🛑 애니메이션 중이면 먼저 정지
        }
        this.animate(false);
    }

    getCurrentState(): {
        position: TAnimationValue;
        velocity: TAnimationValue extends number ? number : Record<string, number>;
        from: TAnimationValue;
        to: TAnimationValue;
    } {
        // 🔍 현재 상태 반환
        return {
            position: this.currentValue,
            velocity: this.velocity,
            from: this.options.from,
            to: this.options.to
        };
    }
}
```

#### 10.2 Transition State Management

```typescript
// packages/core/src/lib/create-transition-callback.ts:17
let currentAnimation: {animator: Animator<TAnimationValue>; direction: "in" | "out"} | null = null;

const runEntrance = async (element: HTMLElement) => {
    // 🎭 상태에 따른 다른 처리
    if (currentClone) {
        currentClone.remove(); // 이전 상태 정리
        currentClone = null;
    }

    // ... 애니메이션 로직

    currentAnimation = {animator, direction: "in"}; // 🔄 상태 업데이트
};
```

### 💰 이점

1. **상태 캡슐화**: 상태별 로직을 명확히 분리
2. **일관성**: 상태 변화가 예측 가능
3. **확장성**: 새로운 상태 추가 용이
4. **디버깅**: 현재 상태를 명확히 파악

### 🚫 사용하지 않았다면?

```typescript
// 😱 상태를 전역 변수로 관리
let isAnimating = false;
let animationDirection = "";
let hasClone = false;
let currentProgress = 0;

function doSomething() {
    if (isAnimating && animationDirection === "in" && !hasClone) {
        // 😵 복잡한 조건 분기
        if (currentProgress > 0.5) {
            // ...
        } else {
            // ...
        }
    } else if (!isAnimating && hasClone) {
        // 😵 또 다른 복잡한 분기
    }
    // 😭 상태 조합 폭발
}
```

**문제점:**

- 상태 조합 복잡성 증가
- 버그 발생 확률 높음
- 디버깅 어려움
- 코드 이해 어려움

---

## 11. 기타 패턴들

### 11.1 Decorator Pattern (데코레이터 패턴)

```typescript
// packages/core/src/lib/utils.ts:5
export const prepareOutgoing = (element: HTMLElement): void => {
    // 🎨 기존 요소에 스타일을 추가로 장식
    element.style.position = "absolute";
    element.style.width = "100%";
    element.style.top = "0";
    element.style.left = "0";
};
```

### 11.2 Proxy Pattern (프록시 패턴)

```typescript
// React Context가 Core 접근을 중재
const useSsgoi = () => {
    const context = useContext(SsgoiContextInstance);
    if (!context) {
        throw new Error("useSsgoi must be used within SsgoiProvider");
    }
    return context; // 🛡️ 안전한 접근 보장
};
```

### 11.3 Chain of Responsibility Pattern

```typescript
// packages/core/src/lib/create-ssgoi-transition-context.ts:223
function findMatchingTransition(from: string, to: string, transitions: Array<any>) {
    // 🔗 정확한 매치 먼저 시도
    for (const config of transitions) {
        if (matchPath(from, config.from) && matchPath(to, config.to)) {
            return config.transition;
        }
    }

    // 🔗 와일드카드 매치 시도
    for (const config of transitions) {
        if ((config.from === "*" || matchPath(from, config.from)) && (config.to === "*" || matchPath(to, config.to))) {
            return config.transition;
        }
    }

    return null; // 🔗 체인 끝
}
```

---

## 12. 패턴들의 상호작용

### 12.1 패턴 조합 예시

```typescript
// 여러 패턴이 함께 동작하는 예시
function createComplexTransition() {
    // 1. Factory Pattern - 객체 생성
    const animator = Animator.fromState(initialState, options);

    // 2. Strategy Pattern - 전략 선택
    const strategy = createDefaultStrategy(context);

    // 3. Observer Pattern - 상태 변화 관찰
    animator.onUpdate = value => {
        // 4. Command Pattern - 명령 실행
        executeCommand("updateDOM", value);
    };

    // 5. State Pattern - 상태 관리
    currentAnimation = {animator, direction: "in"};

    return animator;
}
```

### 12.2 패턴 간 의존성

```
Facade (React)
    ↓
Adapter (React ↔ Core)
    ↓
Factory (Context 생성)
    ↓
Registry (Transition 등록)
    ↓
Template Method (Transition 구조)
    ↓
Strategy (애니메이션 전략)
    ↓
Command (애니메이션 실행)
    ↓
Observer (상태 변화 알림)
    ↓
State (애니메이션 상태)
```

---

## 13. 주니어 개발자를 위한 학습 포인트

### 13.1 패턴 학습 순서 (난이도별)

#### 🟢 초급 (먼저 익혀야 할 패턴)

1. **Observer Pattern**: 이벤트 시스템의 기본
2. **Factory Pattern**: 객체 생성의 기본
3. **Builder Pattern**: 설정 객체 만들기

#### 🟡 중급 (다음에 익힐 패턴)

4. **Strategy Pattern**: 알고리즘 교체하기
5. **Command Pattern**: 작업을 객체로 만들기
6. **Template Method**: 공통 구조 만들기

#### 🔴 고급 (마지막에 익힐 패턴)

7. **Facade Pattern**: 복잡한 시스템 감싸기
8. **State Pattern**: 상태별 행동 관리
9. **Registry Pattern**: 전역 객체 관리

### 13.2 실습 아이디어

#### Observer 패턴 연습

```typescript
// 간단한 이벤트 시스템 만들기
class EventEmitter {
    private listeners = new Map<string, Function[]>();

    on(event: string, callback: Function) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(callback);
    }

    emit(event: string, data: any) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(callback => callback(data));
    }
}
```

#### Factory 패턴 연습

```typescript
// 다양한 버튼 만들기
class ButtonFactory {
    static create(type: "primary" | "secondary", text: string) {
        switch (type) {
            case "primary":
                return new PrimaryButton(text);
            case "secondary":
                return new SecondaryButton(text);
            default:
                throw new Error("Unknown button type");
        }
    }
}
```

### 13.3 SSGOI 코드 읽기 가이드

#### 1단계: 구조 파악

- `packages/react/` - React 인터페이스 (Facade)
- `packages/core/` - 핵심 로직 (다양한 패턴들)

#### 2단계: 주요 파일 읽기 순서

1. `types.ts` - 타입 정의 이해
2. `animator.ts` - 애니메이션 엔진 (State Pattern)
3. `transition.ts` - 전환 관리 (Registry Pattern)
4. `view-transitions/fade.ts` - 간단한 구현 (Template Method)

#### 3단계: 패턴 찾기 연습

각 파일을 읽으면서 "어떤 패턴이 사용되었을까?" 생각해보기

### 13.4 안티패턴 피하기

#### ❌ 피해야 할 것들

```typescript
// God Object - 모든 기능을 한 클래스에
class SsgoiEverything {
    createAnimation() {
        /* ... */
    }
    manageTransitions() {
        /* ... */
    }
    handleRouting() {
        /* ... */
    }
    updateDOM() {
        /* ... */
    }
    // 😱 너무 많은 책임
}

// Spaghetti Code - 패턴 없는 복잡한 코드
function doEverything(type: string, options: any) {
    if (type === "fade") {
        if (options.direction === "in") {
            if (options.spring) {
                // 😵 끝없는 중첩
            }
        }
    }
}
```

#### ✅ 좋은 예시 (SSGOI처럼)

```typescript
// Single Responsibility - 각 클래스가 하나의 책임
class Animator {
    // 애니메이션만 담당
}

class TransitionRegistry {
    // 전환 등록/관리만 담당
}

class ReactAdapter {
    // React 연결만 담당
}
```

---

## 14. 결론

SSGOI는 다양한 디자인 패턴을 적절히 조합하여 다음을 달성했습니다:

### 🎯 달성한 목표들

1. **확장성**: 새로운 전환 쉽게 추가 가능
2. **재사용성**: 프레임워크 간 코어 로직 공유
3. **유지보수성**: 패턴으로 구조화된 깔끔한 코드
4. **테스트 용이성**: 각 패턴별로 독립적 테스트
5. **성능**: 효율적인 메모리 사용과 실행

### 📚 주니어 개발자에게 주는 교훈

1. **패턴은 도구**: 목적에 맞는 패턴 선택이 중요
2. **과도한 패턴 금지**: 단순한 것에 복잡한 패턴 사용 금지
3. **점진적 학습**: 한 번에 모든 패턴을 익히려 하지 말 것
4. **실제 코드 읽기**: 이론보다 실제 구현에서 학습
5. **팀원과 소통**: 패턴 사용시 팀원들과 충분한 소통

### 🚀 다음 단계

SSGOI 코드를 읽으면서:

1. 각 패턴이 **왜** 선택되었는지 생각해보기
2. 다른 방법으로 구현했다면 **어떤 문제**가 있을지 상상해보기
3. 자신의 프로젝트에 **어떤 패턴**을 적용할 수 있을지 고민해보기

**기억하세요**: 디자인 패턴은 은총알이 아닙니다. 문제를 해결하는 도구일 뿐이고, 적절한 상황에서 적절하게 사용하는 것이 핵심입니다! 🎯
