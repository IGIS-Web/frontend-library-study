# SSGOI Element Cloning 메커니즘: React Router 언마운트 시 애니메이션이 가능한 이유

## 핵심 질문

**"React Router에서 페이지가 언마운트되면 DOM 요소가 사라지는데, 어떻게 이전 페이지의 애니메이션이 가능할까?"**

답: **Element Cloning (요소 복제)** - React의 ref cleanup 타이밍을 이용한 영리한 해결책

## 1. React 컴포넌트 라이프사이클과 SSGOI 개입 시점

### React Router의 일반적인 페이지 전환 과정
```
1. 사용자가 새로운 라우트로 이동 (예: "/" → "/about")
2. React Router: 이전 컴포넌트 언마운트 과정 시작
3. React: ref cleanup 함수들 실행 ← 🔥 SSGOI가 개입하는 시점!
4. React: DOM에서 요소들 완전 제거
5. React Router: 새로운 컴포넌트 마운트 시작
6. React: 새 페이지 DOM 요소들 생성
```

### SSGOI의 개입 전략
SSGOI는 **3번 시점 (ref cleanup)**에서 동작합니다:
- ✅ DOM 요소가 아직 살아있음
- ✅ 완전한 복제 가능
- ✅ React 제거 프로세스를 방해하지 않음

## 2. Element Cloning 메커니즘 상세 분석

### 2.1 SsgoiTransition의 ref cleanup 함수

`packages/react/src/lib/ssgoi-transition.tsx:11`:
```typescript
export const SsgoiTransition = ({children, id}: {children: ReactNode; id: string}) => {
    const getTransition = useSsgoi();

    return (
        <div ref={transition(getTransition(id))} data-ssgoi-transition={id}>
            {children}
        </div>
    );
};
```

### 2.2 transition 함수의 cleanup 반환

`packages/core/src/lib/create-transition-callback.ts:129-140`:
```typescript
return (element: HTMLElement | null) => {
  if (!element) return;
  
  // 부모 참조 저장 (복제본 삽입용)
  parentRef = element.parentElement;
  nextSiblingRef = element.nextElementSibling;

  runEntrance(element); // IN 애니메이션 준비

  return () => {  // 🔥 React ref cleanup 함수
    // React가 원본을 제거하기 직전에 복제!
    const cloned = element.cloneNode(true) as HTMLElement;
    runExitTransition(cloned); // 복제본으로 OUT 애니메이션 실행
  };
};
```

**핵심 포인트:**
- `cloneNode(true)`: 요소와 모든 하위 요소 완전 복제
- 원본 요소가 아직 DOM에 있을 때 복제 실행
- 복제 후 즉시 OUT 애니메이션 시작

### 2.3 복제본 DOM 삽입과 애니메이션

`packages/core/src/lib/create-transition-callback.ts:74-127`:
```typescript
const runExitTransition = async (element: HTMLElement) => {
  currentClone = element; // 복제된 요소 저장

  const transition = getTransition();
  const configs: TransitionConfigs<TAnimationValue> = {
    in: transition.in && Promise.resolve(transition.in(element)),
    out: transition.out && Promise.resolve(transition.out(element)),
  };

  const setup = await strategy.runOut(configs);
  setup.config.prepare?.(element); // prepareOutgoing 실행

  insertClone(); // 🔥 복제본을 DOM에 다시 삽입!

  // 애니메이션 시작
  const animator = Animator.fromState(setup.state, {
    from: setup.from, // 1 (완전히 보임)
    to: setup.to,     // 0 (완전히 사라짐)
    spring: setup.config.spring,
    onUpdate: setup.config.tick, // opacity 변경
    onComplete: () => {
      if (currentClone) {
        currentClone.remove(); // 🔥 애니메이션 완료 후 복제본 제거
        currentClone = null;
      }
      currentAnimation = null;
    },
  });

  animator.forward(); // 애니메이션 실행
};
```

### 2.4 insertClone 함수

`packages/core/src/lib/create-transition-callback.ts:118-127`:
```typescript
function insertClone() {
  if (!parentRef || !currentClone) return;

  // 원래 위치에 복제본 삽입
  if (nextSiblingRef && parentRef.contains(nextSiblingRef)) {
    parentRef.insertBefore(currentClone, nextSiblingRef);
  } else {
    parentRef.appendChild(currentClone);
  }
}
```

## 3. 실제 DOM 상태 변화 타임라인

### 초기 상태: "/" 페이지
```html
<div id="root">
  <div ref={transition} data-ssgoi-transition="/">
    <h1>Home Page</h1>
    <p>Welcome to home!</p>
  </div>
</div>
```

### Phase 1: React Router 언마운트 시작 + SSGOI 복제
```html
<div id="root">
  <!-- 원본: React가 곧 제거할 예정 -->
  <div ref={transition} data-ssgoi-transition="/">
    <h1>Home Page</h1>
    <p>Welcome to home!</p>
  </div>
  
  <!-- 복제본: SSGOI가 생성 (아직 보이지 않음) -->
  <div style="opacity: 1; position: absolute;">
    <h1>Home Page</h1>
    <p>Welcome to home!</p>
  </div>
</div>
```

### Phase 2: React 언마운트 완료 + "/about" 마운트 시작
```html
<div id="root">
  <!-- 원본 제거됨 -->
  
  <!-- 복제본: fade out 애니메이션 중 -->
  <div style="opacity: 0.7; position: absolute;">
    <h1>Home Page</h1>
    <p>Welcome to home!</p>
  </div>
  
  <!-- 새 페이지: fade in 애니메이션 중 -->
  <div ref={transition} data-ssgoi-transition="/about" style="opacity: 0.3;">
    <h1>About Page</h1>
    <p>Learn more about us!</p>
  </div>
</div>
```

### Phase 3: 애니메이션 진행 중
```html
<div id="root">
  <!-- 복제본: 계속 fade out -->
  <div style="opacity: 0.3; position: absolute;">
    <h1>Home Page</h1>
    <p>Welcome to home!</p>
  </div>
  
  <!-- 새 페이지: 계속 fade in -->
  <div ref={transition} data-ssgoi-transition="/about" style="opacity: 0.7;">
    <h1>About Page</h1>
    <p>Learn more about us!</p>
  </div>
</div>
```

### Phase 4: 애니메이션 완료
```html
<div id="root">
  <!-- 복제본 완전 제거됨 -->
  
  <!-- 새 페이지만 남음 -->
  <div ref={transition} data-ssgoi-transition="/about" style="opacity: 1;">
    <h1>About Page</h1>
    <p>Learn more about us!</p>
  </div>
</div>
```

## 4. fade 애니메이션의 구체적 동작

### OUT 애니메이션 (복제본)
```typescript
// fade out transition
out: (element) => ({
  spring: { stiffness: 300, damping: 30 },
  tick: (progress) => {
    element.style.opacity = progress.toString(); // 1 → 0
  },
  prepare: prepareOutgoing, // position: absolute 등 설정
}),
```

### IN 애니메이션 (새 페이지)
```typescript
// fade in transition  
in: (element) => ({
  spring: { stiffness: 300, damping: 30 },
  tick: (progress) => {
    element.style.opacity = progress.toString(); // 0 → 1
  },
}),
```

### 동시 실행 결과
- **복제된 "/" 페이지**: opacity 1.0 → 0.0 (서서히 사라짐)
- **새로운 "/about" 페이지**: opacity 0.0 → 1.0 (서서히 나타남)
- **스프링 물리학**: 자연스러운 easing으로 부드러운 전환

## 5. prepareOutgoing 함수의 역할

`packages/core/src/lib/utils.ts`:
```typescript
export const prepareOutgoing = (element: HTMLElement) => {
  // 복제본이 원본과 겹치지 않도록 absolute positioning
  element.style.position = "absolute";
  element.style.top = "0";
  element.style.left = "0";
  element.style.width = "100%";
  element.style.height = "100%";
  element.style.zIndex = "1000"; // 위에 표시
};
```

**목적:**
- 복제본이 새 페이지와 레이아웃 간섭 방지
- 정확한 위치에서 애니메이션 시작
- z-index로 레이어 순서 보장

## 6. 메모리 관리와 정리

### 자동 정리 메커니즘
```typescript
onComplete: () => {
  setup.config?.onEnd?.();
  if (currentClone) {
    currentClone.remove(); // DOM에서 복제본 완전 제거
    currentClone = null;   // 메모리 참조 해제
  }
  currentAnimation = null; // 애니메이션 상태 초기화
  options?.onCleanupEnd?.(); // 추가 정리 작업
},
```

### 정리 보장
- 애니메이션 완료 시 자동 정리
- 메모리 누수 방지
- DOM 오염 방지

## 7. 왜 이 방식이 효과적인가?

### 장점
1. **완벽한 보존**: 사라지는 페이지의 모든 상태 보존
2. **자연스러운 전환**: 진짜 페이지가 사라지는 것처럼 보임
3. **React 비침습적**: React Router 동작 방해 없음
4. **메모리 효율**: 애니메이션 후 즉시 정리
5. **타이밍 완벽**: ref cleanup 시점 활용

### 해결하는 문제들
- ❌ 페이지 갑작스러운 사라짐/나타남
- ❌ 어색한 화면 깜빡임
- ❌ 네이티브 앱 대비 떨어지는 UX
- ✅ 부드럽고 자연스러운 페이지 전환

## 8. 다른 전환 애니메이션에서의 활용

### hero 전환에서의 복제
```typescript
// hero 전환에서도 같은 원리 적용
out: async (element) => {
  return {
    onStart: () => {
      fromNode = element; // 복제본을 from 기준으로 저장
      if (resolver) {
        resolver(true); // IN 애니메이션에 신호
      }
    },
    prepare: (element) => {
      prepareOutgoing(element);
      element.style.opacity = "0"; // 복제본은 숨김
    },
  };
},
```

## 9. 결론

SSGOI의 Element Cloning 메커니즘은 React의 컴포넌트 라이프사이클을 교묘하게 활용한 혁신적인 해결책입니다:

1. **React ref cleanup 타이밍 활용**: DOM 제거 직전 순간을 포착
2. **완전한 요소 복제**: `cloneNode(true)`로 모든 상태 보존  
3. **독립적 애니메이션**: 복제본과 새 페이지의 동시 애니메이션
4. **자동 정리**: 애니메이션 완료 후 복제본 제거

이를 통해 React Router의 즉각적인 페이지 전환을 자연스러운 애니메이션 전환으로 바꿔주며, 네이티브 앱 수준의 사용자 경험을 웹에서 구현할 수 있습니다.

**핵심**: "사라질 것을 미리 복제해서 보존하고, 복제본으로 애니메이션한다"