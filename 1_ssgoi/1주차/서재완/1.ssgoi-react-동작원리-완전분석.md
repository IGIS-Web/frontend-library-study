# SSGOI React 동작 원리 완전 분석

## 개요

SSGOI는 React에서 페이지 간 자연스러운 애니메이션 전환을 제공하는 라이브러리입니다. 본 문서는 "/" 페이지에서 "/about" 페이지로 이동할 때 fade 애니메이션이 어떻게 동작하는지 함수별 흐름을 상세히 분석합니다.

## 1. 전체 아키텍처 구조

### React 패키지 (Wrapper Layer)
- `@ssgoi/react` 패키지는 `@ssgoi/core`의 React 래퍼
- React Context API를 통한 전역 상태 관리
- React 컴포넌트로 Core 기능을 감싸서 제공

### Core 패키지 (Engine Layer)
- 프레임워크 독립적인 핵심 애니메이션 엔진
- Popmotion 기반 스프링 물리학 애니메이션
- 페이지 간 전환 로직 관리

## 2. 핵심 컴포넌트 분석

### 2.1 Ssgoi Provider (`packages/react/src/lib/ssgoi.tsx:13`)
```typescript
export const Ssgoi: React.FC<SsgoiProps> = ({ config, children }) => {
  const contextValue = useMemo<SsgoiContext>(
    () => createSggoiTransitionContext(config),
    [config]
  );

  return <SsgoiProvider value={contextValue}>{children}</SsgoiProvider>;
};
```

**동작 원리:**
1. `createSggoiTransitionContext(config)`를 호출하여 Core의 전환 컨텍스트 생성
2. React Context Provider를 통해 전체 앱에 컨텍스트 제공
3. `useMemo`로 config 변경시에만 재생성하여 성능 최적화

### 2.2 SsgoiTransition (`packages/react/src/lib/ssgoi-transition.tsx:7`)
```typescript
export const SsgoiTransition = ({children, id}: {children: ReactNode; id: string}) => {
    const getTransition = useSsgoi();

    return (
        <div ref={transition(getTransition(id))} data-ssgoi-transition={id}>
            {children}
        </div>
    );
};
```

**동작 원리:**
1. `useSsgoi()`로 컨텍스트에서 transition getter 함수 획득
2. `getTransition(id)`를 호출하여 해당 페이지의 전환 설정 획득
3. `transition()` 함수를 ref로 전달하여 DOM 라이프사이클 관리

## 3. Core 엔진 동작 분석

### 3.1 createSggoiTransitionContext (`packages/core/src/lib/create-ssgoi-transition-context.ts:129`)

이 함수는 SSGOI의 핵심으로, 페이지 간 전환을 관리하는 중앙 제어 시스템입니다.

**주요 동작:**
1. **설정 처리**: transitions 배열에서 symmetric 전환을 자동 생성
2. **Pending Transition 관리**: OUT과 IN 애니메이션을 동기화
3. **스크롤 위치 추적**: 페이지 간 스크롤 오프셋 계산

**핵심 로직 (`lines 168-193`):**
```typescript
const getTransition = async (path: string, type: "out" | "in") => {
  if (type === "in") {
    // IN은 OUT이 없으면 애니메이션 없음 (페이지 새로고침시)
    if (!pendingTransition || !pendingTransition.from) {
      return () => ({}); // 빈 전환 반환
    }
  }

  if (!pendingTransition) {
    pendingTransition = {};
  }

  if (type === "out") {
    pendingTransition.from = path;
    return new Promise<GetTransitionConfig>(resolve => {
      pendingTransition!.outResolve = resolve;
      checkAndResolve();
    });
  } else {
    pendingTransition.to = path;
    return new Promise<GetTransitionConfig>(resolve => {
      pendingTransition!.inResolve = resolve;
      checkAndResolve();
    });
  }
};
```

### 3.2 checkAndResolve 함수 (`lines 145-166`)

OUT과 IN 애니메이션이 모두 준비되면 실행되는 핵심 함수:

1. **전환 매칭**: `findMatchingTransition()`으로 설정에서 적절한 전환 찾기
2. **스크롤 오프셋 계산**: 페이지 간 스크롤 차이 계산
3. **Promise 해결**: OUT과 IN 애니메이션을 동시에 시작

### 3.3 transition 함수 (`packages/core/src/lib/transition.ts:75`)

React ref로 사용되는 함수로, DOM 요소의 라이프사이클을 관리:

```typescript
export function transition<TAnimationValue = number>(options: {
  key: TransitionKey;
  in?: Transition<undefined, TAnimationValue>["in"];
  out?: Transition<undefined, TAnimationValue>["out"];
}): TransitionCallback {
  return registerTransition(options.key, {
    in: options.in,
    out: options.out,
  });
}
```

**동작:**
1. 전환을 키로 등록
2. `createTransitionCallback()`을 통해 실제 콜백 생성
3. DOM 요소가 마운트/언마운트될 때 애니메이션 실행

### 3.4 createTransitionCallback (`packages/core/src/lib/create-transition-callback.ts:10`)

개별 요소의 애니메이션을 관리하는 핵심 함수로, 4가지 시나리오를 처리:

1. **No animation + IN trigger**: 입장 애니메이션 (0 → 1)
2. **No animation + OUT trigger**: 요소 복제 후 퇴장 애니메이션 (1 → 0)
3. **IN animation running + OUT trigger**: 현재 IN 애니메이션을 자연스럽게 역방향으로 전환
4. **OUT animation running + IN trigger**: 현재 OUT 애니메이션을 자연스럽게 역방향으로 전환

**runEntrance 함수 (`lines 35-72`):**
```typescript
const runEntrance = async (element: HTMLElement) => {
  if (currentClone) {
    currentClone.remove();
    currentClone = null;
  }
  const transition = getTransition();
  const configs: TransitionConfigs<TAnimationValue> = {
    in: transition.in && Promise.resolve(transition.in(element)),
    out: transition.out && Promise.resolve(transition.out(element)),
  };

  const setup = await strategy.runIn(configs);
  if (!setup.config) {
    return;
  }

  setup.config.prepare?.(element);

  const animator = Animator.fromState(setup.state, {
    from: setup.from,
    to: setup.to,
    spring: setup.config.spring,
    onStart: setup.config.onStart,
    onUpdate: setup.config.tick,
    onComplete: () => {
      currentAnimation = null;
      setup.config?.onEnd?.();
    },
  });

  currentAnimation = { animator, direction: "in" };

  if (setup.direction === "forward") {
    animator.forward();
  } else {
    animator.backward();
  }
};
```

### 3.5 Animator 클래스 (`packages/core/src/lib/animator.ts:21`)

Popmotion 기반의 스프링 물리학 애니메이션 엔진:

**주요 기능:**
- **속도 보존**: 애니메이션 중단 시 현재 속도 유지
- **방향 전환**: forward/backward 자연스러운 전환
- **상태 관리**: position, velocity, from, to 추적

## 4. 페이지 전환 시나리오: "/" → "/about" (fade 애니메이션)

### 4.1 초기 설정

```typescript
// layout.tsx
const ssgoiConfig: SsgoiConfig = {
  defaultTransition: fade(),
  transitions: [
    {
      from: "/",
      to: "/about",
      transition: fade(),
      symmetric: true,
    },
  ],
};
```

**fade 전환 정의 (`packages/core/src/lib/view-transitions/fade.ts:8`):**
```typescript
export const fade = (options: FadeOptions = {}): SggoiTransition => {
  const spring: SpringConfig = {
    stiffness: options.spring?.stiffness ?? 300,
    damping: options.spring?.damping ?? 30,
  };

  return {
    in: (element) => ({
      spring,
      tick: (progress) => {
        element.style.opacity = progress.toString();
      },
    }),
    out: (element) => ({
      spring,
      tick: (progress) => {
        element.style.opacity = progress.toString();
      },
      prepare: prepareOutgoing,
    }),
  };
};
```

### 4.2 단계별 동작 흐름

#### Phase 1: "/" 페이지 OUT 애니메이션 시작

1. **사용자가 "/" → "/about" 네비게이션 트리거**

2. **React Router가 "/" 페이지 언마운트 시작**

3. **SsgoiTransition의 cleanup 함수 실행**
   - `packages/react/src/lib/ssgoi-transition.tsx:11`의 ref가 정리 함수 호출
   - `packages/core/src/lib/create-transition-callback.ts:136-140`:
   ```typescript
   return () => {
     const cloned = element.cloneNode(true) as HTMLElement;
     runExitTransition(cloned);
   };
   ```

4. **createSggoiTransitionContext의 getTransition("/", "out") 호출**
   - `packages/core/src/lib/create-ssgoi-transition-context.ts:180-185`:
   ```typescript
   if (type === "out") {
     pendingTransition.from = path; // "/" 설정
     return new Promise<GetTransitionConfig>(resolve => {
       pendingTransition!.outResolve = resolve;
       checkAndResolve(); // 아직 'to'가 없어서 대기
     });
   }
   ```

5. **pendingTransition 상태**:
   ```typescript
   pendingTransition = {
     from: "/",
     outResolve: [Promise resolver function]
   }
   ```

#### Phase 2: "/about" 페이지 IN 애니메이션 시작

1. **React Router가 "/about" 페이지 마운트 시작**

2. **SsgoiTransition 컴포넌트 렌더링**
   ```typescript
   <SsgoiTransition id="/about">
     {aboutPageContent}
   </SsgoiTransition>
   ```

3. **transition ref 함수 실행**
   - `packages/core/src/lib/create-transition-callback.ts:129-135`:
   ```typescript
   return (element: HTMLElement | null) => {
     if (!element) return;
     parentRef = element.parentElement;
     nextSiblingRef = element.nextElementSibling;

     runEntrance(element); // IN 애니메이션 시작
   };
   ```

4. **createSggoiTransitionContext의 getTransition("/about", "in") 호출**
   - `packages/core/src/lib/create-ssgoi-transition-context.ts:186-193`:
   ```typescript
   } else {
     pendingTransition.to = path; // "/about" 설정
     return new Promise<GetTransitionConfig>(resolve => {
       pendingTransition!.inResolve = resolve;
       checkAndResolve(); // 이제 from과 to 모두 있음!
     });
   }
   ```

#### Phase 3: 전환 매칭 및 Promise 해결

1. **checkAndResolve 실행** (`packages/core/src/lib/create-ssgoi-transition-context.ts:145-166`)
   ```typescript
   function checkAndResolve() {
     if (pendingTransition?.from && pendingTransition?.to) {
       // "/" → "/about" 매칭
       const {from: transformedFrom, to: transformedTo} = middleware("/", "/about");
       
       const transition = findMatchingTransition(transformedFrom, transformedTo, processedTransitions);
       const result = transition || defaultTransition; // fade() 반환
       const scrollOffset = calculateScrollOffset("/", "/about");
       const context = {scrollOffset};

       if (result) {
         if (result.out && pendingTransition.outResolve) {
           pendingTransition.outResolve(element => result.out!(element, context));
         }
         if (result.in && pendingTransition.inResolve) {
           pendingTransition.inResolve(element => result.in!(element, context));
         }
       }

       pendingTransition = null; // 초기화
     }
   }
   ```

2. **findMatchingTransition이 fade() 전환 반환**

3. **OUT과 IN Promise 동시 해결**:
   - OUT: fade의 out 함수를 받아 복제된 "/" 페이지 요소에 적용
   - IN: fade의 in 함수를 받아 "/about" 페이지 요소에 적용

#### Phase 4: 실제 애니메이션 실행

1. **OUT 애니메이션 (복제된 "/" 페이지)**
   
   `runExitTransition` 실행 (`packages/core/src/lib/create-transition-callback.ts:74-127`):
   ```typescript
   const runExitTransition = async (element: HTMLElement) => {
     currentClone = element; // 복제된 "/" 페이지 요소

     const transition = getTransition(); // fade() 정의
     const configs: TransitionConfigs<TAnimationValue> = {
       in: transition.in && Promise.resolve(transition.in(element)),
       out: transition.out && Promise.resolve(transition.out(element)),
     };

     const setup = await strategy.runOut(configs); // OUT 전략 실행
     
     setup.config.prepare?.(element); // prepareOutgoing 호출

     insertClone(); // DOM에 복제 요소 삽입

     const animator = Animator.fromState(setup.state, {
       from: setup.from, // 1
       to: setup.to,     // 0  
       spring: setup.config.spring, // { stiffness: 300, damping: 30 }
       onStart: setup.config.onStart,
       onUpdate: setup.config.tick, // (progress) => element.style.opacity = progress.toString()
       onComplete: () => {
         setup.config?.onEnd?.();
         if (currentClone) {
           currentClone.remove(); // 복제 요소 제거
           currentClone = null;
         }
         currentAnimation = null;
         options?.onCleanupEnd?.();
       },
     });

     currentAnimation = { animator, direction: "out" };
     animator.forward(); // 1 → 0 애니메이션 (fade out)
   };
   ```

2. **IN 애니메이션 ("/about" 페이지)**
   
   `runEntrance` 실행 (`packages/core/src/lib/create-transition-callback.ts:35-72`):
   ```typescript
   const runEntrance = async (element: HTMLElement) => {
     const transition = getTransition(); // fade() 정의
     const configs: TransitionConfigs<TAnimationValue> = {
       in: transition.in && Promise.resolve(transition.in(element)),
       out: transition.out && Promise.resolve(transition.out(element)),
     };

     const setup = await strategy.runIn(configs); // IN 전략 실행
     
     setup.config.prepare?.(element); // fade의 경우 prepare 없음

     const animator = Animator.fromState(setup.state, {
       from: setup.from, // 0
       to: setup.to,     // 1
       spring: setup.config.spring, // { stiffness: 300, damping: 30 }
       onStart: setup.config.onStart,
       onUpdate: setup.config.tick, // (progress) => element.style.opacity = progress.toString()
       onComplete: () => {
         currentAnimation = null;
         setup.config?.onEnd?.();
       },
     });

     currentAnimation = { animator, direction: "in" };
     animator.forward(); // 0 → 1 애니메이션 (fade in)
   };
   ```

#### Phase 5: Popmotion 애니메이션 실행

1. **Animator.forward() 호출**
   
   `packages/core/src/lib/animator.ts:263-266`:
   ```typescript
   forward(): void {
     this.stop();
     this.animate(false); // reverse = false
   }
   ```

2. **animate 메서드 실행** (`packages/core/src/lib/animator.ts:59-153`):
   ```typescript
   private animate = (reverse: boolean = false) => {
     this.isAnimating = true;
     const target = reverse ? this.options.from : this.options.to;
     
     // OUT: from=1, to=0, target=0
     // IN:  from=0, to=1, target=1
     
     const animateOptions: any = {
       from: this.currentValue, // 현재 위치
       to: target,              // 목표 위치
       stiffness: this.options.spring.stiffness, // 300
       damping: this.options.spring.damping,     // 30
       mass: 1,
     };

     if (typeof this.velocity === "number") {
       animateOptions.velocity = this.velocity * 1000;
     }

     this.controls = animate({ // Popmotion animate 호출
       ...animateOptions,
       onUpdate: (value: TAnimationValue) => {
         // 속도 계산 및 업데이트
         this.currentValue = value;
         this.options.onUpdate(value); // fade tick 함수 호출
       },
       onComplete: () => {
         this.currentValue = target;
         this.isAnimating = false;
         this.controls = null;
         this.options.onComplete();
       },
     });
   };
   ```

3. **fade tick 함수 실행**:
   ```typescript
   // OUT 애니메이션: progress 1 → 0
   tick: (progress) => {
     element.style.opacity = progress.toString(); // opacity: 1 → 0
   }
   
   // IN 애니메이션: progress 0 → 1  
   tick: (progress) => {
     element.style.opacity = progress.toString(); // opacity: 0 → 1
   }
   ```

### 4.3 애니메이션 타이밍

1. **OUT과 IN 애니메이션이 동시에 시작**
2. **OUT**: "/" 페이지 복제본이 opacity 1 → 0으로 페이드 아웃
3. **IN**: "/about" 페이지가 opacity 0 → 1로 페이드 인
4. **스프링 물리학**: stiffness=300, damping=30으로 자연스러운 움직임
5. **완료 시**: OUT 복제본 제거, 애니메이션 상태 정리

## 5. 핵심 설계 패턴

### 5.1 Promise 기반 동기화
- OUT과 IN 애니메이션이 서로를 기다려 동시 시작
- `pendingTransition` 객체로 상태 관리

### 5.2 Element Cloning
- OUT 애니메이션을 위해 떠나는 페이지 복제
- DOM에서 제거된 요소의 애니메이션 가능

### 5.3 Strategy Pattern
- `createDefaultStrategy`로 4가지 애니메이션 시나리오 처리
- 자연스러운 방향 전환 (IN running + OUT trigger → IN reverse)

### 5.4 Spring Physics
- Popmotion의 스프링 물리학으로 자연스러운 움직임
- 속도 보존으로 부드러운 방향 전환

### 5.5 Framework Abstraction
- Core 패키지는 프레임워크 독립적
- React 패키지는 얇은 래퍼 역할

## 6. 성능 최적화 요소

1. **Lazy Loading**: 전환 설정은 필요할 때만 생성
2. **Memory Management**: 애니메이션 완료 시 자동 정리
3. **Velocity Preservation**: 끊김 없는 방향 전환
4. **DOM Optimization**: 필요한 경우에만 복제 요소 생성
5. **Context Memoization**: React의 useMemo로 불필요한 재생성 방지

## 7. 결론

SSGOI는 정교한 상태 관리와 물리학 기반 애니메이션을 통해 네이티브 앱 수준의 페이지 전환을 웹에서 구현합니다. Promise 기반 동기화, 요소 복제, 스프링 물리학의 조합으로 자연스럽고 부드러운 사용자 경험을 제공합니다.

핵심은 OUT과 IN 애니메이션의 동기화된 실행과, 각 애니메이션이 독립적으로 관리되면서도 전체적으로 조화롭게 동작하는 아키텍처에 있습니다.