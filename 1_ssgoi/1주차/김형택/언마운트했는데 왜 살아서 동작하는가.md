
# createTransitionCallback함수에서 어떻게 종료 애니메이션을 구현하는가?
## 함수의 return  부분
```ts
return (element: HTMLElement | null) => {
    if (!element) return;
    parentRef = element.parentElement;
    nextSiblingRef = element.nextElementSibling;

    runEntrance(element);

    return () => {
      const cloned = element.cloneNode(true) as HTMLElement;
      runExitTransition(cloned);
    };
  };
```
마운트 시점에 부모 엘리먼트와 형제 엘리먼트를 기억한다.  
타겟 엘리먼트가 언마운트되어 삭제되는 시점에 복제한 타겟 엘리먼트를 배치시킬 때 사용된다.
복제한 타겟 엘리먼트는 퇴장 애니메이션을 수행한 후 삭제된다.
##
# runExitTransition 함수 알아보기

```ts
const runExitTransition = async (element: HTMLElement) => {
    currentClone = element; //복제본을 보관  

    const transition = getTransition();

    const configs: TransitionConfigs<TAnimationValue> = {
      in: transition.in && Promise.resolve(transition.in(element)),
      out: transition.out && Promise.resolve(transition.out(element)),
    };

    const setup = await strategy.runOut(configs); 
    if (!setup.config) {
      return;
    }

    setup.config.prepare?.(element); //복제본의 스타일/레이아웃 준비

    insertClone(); //복제본을 부모, 형제 엘리먼트를 참고하여 원래 자리에 배치

    //복제본에 대해 out 애니메이션 설정
    const animator = Animator.fromState(setup.state, {
      from: setup.from,
      to: setup.to,
      spring: setup.config.spring,
      onStart: setup.config.onStart,
      onUpdate: setup.config.tick,
      onComplete: () => { //애니메이션 종료시
        setup.config?.onEnd?.();
        if (currentClone) {
          currentClone.remove(); //복제본 삭제
          currentClone = null;
        }
        currentAnimation = null;
        options?.onCleanupEnd?.();
      },
    });

    currentAnimation = { animator, direction: "out" };

    //out애니메이션 실행
    if (setup.direction === "forward") {
      animator.forward();
    } else {
      animator.backward();
    }

    function insertClone() {
      if (!parentRef || !currentClone) return;

      if (nextSiblingRef && parentRef.contains(nextSiblingRef)) {
        parentRef.insertBefore(currentClone, nextSiblingRef);
      } else {
        parentRef.appendChild(currentClone);
      }
    }
  };
```
##
## 정리  
원본은 프레임워크에 의해 곧바로 사라지지만, 그 순간 똑같이 생긴 복제본을 같은 자리에 꽂아 계속 움직이게 합니다. 덕분에 부드러운 퇴장 애니메이션이 끊기지 않고 끝까지 보이게 됩니다.