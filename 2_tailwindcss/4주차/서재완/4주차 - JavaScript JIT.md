# **JavaScript JIT**

앞에서 JIT이 어떤 역할을 하는지, 그리고 TailwindCSS의 JIT이 어떤 식으로 동작하는지 살펴봤습니다. 이제 시야를 JavaScript 엔진 쪽으로 옮겨서, **JavaScript 엔진 안에서 JIT이 어떻게 동작하는지** 조금 더 구체적으로 정리해 보겠습니다.

## 동작 방법

브라우저마다 사용하는 JavaScript 엔진은 다르지만, 여기서는 Chrome에서 사용하는 **V8 엔진**을 기준으로 설명하겠습니다.

예시 시나리오는 **React로 빌드된 결과물이 브라우저에 렌더링되는 과정**이라고 생각하고 따라가 보겠습니다.

### 브라우저 단계

먼저 브라우저가 하는 일을 단계별로 나누면 대략 다음과 같습니다.

-   `index.html` 문서를 파싱한다.
-   파싱 도중 `<script src="main.js"></script>` 같은 스크립트 태그를 만나면, 해당 JS 파일을 네트워크에서 다운로드한다.
-   다운로드가 끝나면, JS 소스를 **JavaScript 엔진(V8)** 에 넘긴다.

여기까지가 “브라우저”가 하는 일이고, 그 다음부터는 V8 내부의 영역입니다.

### V8 - 파싱 & 바이트코드 생성

V8 엔진은 넘겨받은 JS 코드를 바로 실행하지 않고, 먼저 다음 과정을 거칩니다.

-   JS 소스를 **파싱(parsing)** 해서 **AST(추상 구문 트리)** 를 만든다.
-   이 AST를 기반으로, 인터프리터가 실행할 **바이트코드(bytecode)** 로 컴파일한다.

이 단계에서 V8은 JS 코드를 한 번 훑으면서 전체 구조를 이해하게 됩니다.

### AST가 뭘까?

AST는 **Abstract Syntax Tree(추상 구문 트리)** 의 줄임말입니다.

> 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다.
> 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다.

간단히 말하면, **소스 코드를 엔진이 이해하기 좋게 ‘구조화한 트리 형태의 표현’**입니다.

예를 들어, 다음과 같은 코드가 있다고 해볼게요.

```jsx
const sum = 1 + 2 * 3;
```

사람 눈에는 한 줄짜리 코드일 뿐이지만, V8 입장에서는 이 코드가

-   `const sum` → 변수 선언
-   `=` 오른쪽에는 **표현식(Expression)** 이 있고
-   그 표현식 안에는 `+` 연산이 있으며
-   `+`의 오른쪽 피연산자는 다시 `2 * 3` 이라는 곱셈 연산이다

라는 식으로 **“무엇이 무엇의 안에 들어있는지”** 구조를 알아야 합니다.

이런 구조 정보를 **트리 형태로 표현한 것**이 바로 AST입니다.

-   트리의 루트에는 “할당(=)”이라는 노드가 있고
-   왼쪽에는 `sum`이라는 변수 노드
-   오른쪽에는 `+`라는 연산 노드
-   그 아래로 `1` 과 `2 * 3` 같은 하위 노드들이 붙어 있는 식으로 표현됩니다.

이 AST를 기반으로, 엔진은

-   문법 오류를 체크하고
-   바이트코드를 만들고
-   나중에 최적화(JIT) 단계에서 “이 연산은 더 빠르게 바꿀 수 있겠다” 같은 판단을 하게 됩니다.

잠깐 AST 이야기를 했지만, 다시 JIT의 실제 동작으로 돌아가 보겠습니다.

---

### V8 - 인터프리터로 실행

이제 인터프리터가 **바이트코드**를 실행하면서 실제 JS 코드가 동작합니다.

-   이때 단순히 “실행만” 하는 것이 아니라, 동시에 다음과 같은 **프로파일 정보**를 수집합니다.
    -   이 함수가 얼마나 자주 호출되는지
    -   인자로 어떤 타입·객체 모양(shape)이 실제로 들어오는지
    -   프로퍼티 접근이 어떤 패턴으로 일어나는지

이 정보들이 나중에 **JIT 최적화 여부를 판단하는 근거**가 됩니다.

### 실행 중 “핫 함수”라고 판단되면 JIT 최적화

실행을 계속하다 보면, V8이 보기에도 “이 함수는 꽤 자주 쓰인다”라고 판단되는 지점이 생깁니다.

-   어떤 함수가 **충분히 자주 호출되고**,
    들어오는 값들의 **타입 패턴도 안정적**이라고 판단되면,
    → JIT 컴파일러가 개입해서 **해당 함수만 골라서 기계어 코드로 컴파일(최적화)** 합니다.
-   이렇게 만들어진 기계어 코드는 캐시에 저장해 두고,
    이후에 같은 함수를 다시 호출할 때는
    → 인터프리터로 바이트코드를 해석하지 않고, **이미 만들어 둔 기계어를 바로 실행**해서 더 빠르게 처리합니다.

정리하면,

1. 처음에는 “느리지만 유연한” 인터프리터 모드로 실행하면서,
2. 실행 패턴을 보고 “핫 함수”를 고른 다음,
3. 그 부분만 “빠른 기계어 코드”로 바꿔서 재사용하는 것이 JavaScript의 JIT 동작흐름입니다.

## 이 방법이 정말 좋은 방법일까?

동작 방법을 알고 보니 의문이 생겼습니다. JIT가 정말 의미가 있는 방법일지 말이죠.

1. “처음엔 인터프리터로 돌면서 “핫할 것 같은 함수”를 골라서 JIT 최적화를 한다”
2. “근데 그 판단이 빗나가서, 한 번 최적화 하고 다시 안쓰면?”
3. 오히려 최적화를 한 작업이 의미없는 작업이 아닐까?

### JIT이 “틀릴 수 있는데”도 쓰는 이유

인터프리터와 JIT를 비교하면 다음과 같습니다 :

-   인터프리터만 사용할 때 :
    -   준비 시간(compile) 거의 없음
    -   매 실행이 느리지만 일정하게 느림
-   JIT을 사용할 때 :
    -   초반에 프로파일 수집 + 최적화 컴파일이라는 추가 비용 존재
    -   핫한 코드는 빠르게 실행 가능

즉, JIT의 가정은 :

> “현실 세계의 대부분 프로그램은 일부 코드가 엄청 자주 실행된다.
> 그 부분만 최적화해도 전체 체감 성능이 비약적으로 좋아진다.”

웹에서의 React 코드를 보면 :

-   렌더링 루프
-   React 렌더링 사이클
-   자주 호출되는 유틸 함수
-   이벤트 핸들러
-   tight loop 영역

같이 반복해서 도는 구간이 생각보다 많습니다.

### 렌더링 루프

브라우저는 화면을 1초에 60번 정도 갱신한느데, 이 주기를 기준으로 돌아가는 루프가 렌더링 루프입니다.

여기서 JS에서 끼어드는 대표적인 API가 `requestAnimationFrame`입니다.

```jsx
function loop(timestamp) {
    updateState(timestamp);
    // ...

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
```

`loop` 함수는 사용자가 페이지를 열어 두는 동안 계속 호출되니까,
JIT 입장에서는 “아주 자주 호출되는 함수(핫 함수)” 후보가 됩니다.

### React 렌더링 사이클

React 공식 문서 기준으로, [렌더링은 3단계](https://react.dev/learn/render-and-commit?utm_source=chatgpt.com)로 설명됩니다 :

1.  **Trigger**
    - 최초 렌더 : `createRoot(...).render<App />)` 호출
    - 이후 : `setState`, `useState`, `useReducer` 등으로 **state/props가 바뀔 때마다** 다시 렌더링이 트리거 됨
2.  **Render Phase**
    이 단계에서 JS 코드가 **엄청 많이 실행**됩니다. - React가 해당 컴포넌트 트리의 **Fiber 트리**를 순회하면서, 각 컴포넌트 함수를 호출해 새로운 React Element / Virtual DOM 정보를 만듭니다. - 새로 만들어진 “가상의 UI 정보(새 Fiber 트리 / Virtual DOM)”와 기존의 트리를 비교하는 과정을 **Reconciliation (조정)** 이라고 부릅니다. - 어떤 노드를 그대로 둘지 - 어떤 노드를 추가/삭제/변경할지 - 어떤 DOM 속성이 바뀌었는지
            계산해서 **업데이트 리스트**를 만듭니다.


        핵심은:

        - 모든 작업이 **JS 함수들로 되어 있고**,
        - 상태 변경이 일어나면 **React 내부의 Render/Reconciliation 관련 JS 함수들이 계속 호출**됩니다.
3.  **Commit Phase**
    - Render Phase에서 만든 “업데이트 리스트”를 **실제 DOM에 반영**하는 단계
    - 여기서 실제 DOM 조작이 일어나고, `useLayoutEffect`, `useEffect` 같은 훅이 실행됩니다.

### 자주 호출되는 유틸 함수

-   개발자가 직접 작성한 헬퍼 함수
    예) `formatDate`, `clamp`, `classNames` 등 작성한 어떤 것들도 다 포함
-   라이브러리가 제공하는 반복 호출되는 함수

를 전부 포함한 개념입니다. 자주 실행되는 함수라면 핫한 함수로 보고 최적화를 진행합니다.

```jsx
const formatMoney = (v: number) => {
    return value.toLocaleString("ko-KR", {style: "currency", currency: "KRW"});
};

prices.map(formatMoney);
```

`formatMoney`를 수백·수천 번 호출한다면 JIT가 최적화를 진행할 수 있습니다.

### 이벤트 핸들러

많은 이벤트 핸들러, 특히 **스크롤·리사이즈·mousemove** 는 브라우저가 자주 호출될 수 있어서, 핫 한 코드가 될 수 있습니다.

```jsx
window.addEventListener("scroll", () => {
    // 스크롤 될 때마다 실행
});
```

이런 핸들러는 한 번 스크롤할 때 **수십~수백 번 호출**될 수 있기 때문에,

**“실행 횟수”만 보면 렌더 루프 못지않게 핫한 코드**가 될 수 있습니다.

### tight loop

먼저 tight loop는 반복 횟수가 많고, 본문이 비교적 짧아서 CPU가 같은 코드 블록을 많이 도는 루프입니다.

예를 들어 :

```jsx
let sum = 0;
for (let i = 0; i < 10_000_000; i++) {
    sum += arr[i];
}
```

다음과 같은 경우가 tight loop 입니다.

-   같은 코드 조각이 수백만 번 반복
-   JIT 입장에서는 최적화를 잘 하면 전체 실행 시간이 크게 줄어드는 구간

이기 때문입니다.

# 그렇다면 이걸 개발에는 어떻게 신경 써야 할까?

JIT이 뭔지, TailwindCSS에서 이야기하는 JIT, 그리고 JavaScript 엔진에서의 JIT 동작까지 한 번 훑어봤습니다.

이제 중요한 건 “아, 그렇구나”에서 끝나는 게 아니라 **실제 코드 짤 때 뭘 신경 쓰면 좋은가**입니다.
우리가 직접 JIT을 켜고 끄는 건 불가능하지만, **엔진이 최적화하기 좋은 코드 패턴**을 의식하면서 개발할 수는 있습니다.

기본 전제는 이렇습니다.

-   JIT은 **브라우저/엔진이 알아서 돌리는 기능**이고,
-   우리는 “이 코드가 자주, 일관되게 실행된다”는 힌트를 엔진에 주는 쪽으로 코드를 짤 수 있습니다.

그 관점에서 함수를 어떻게 만들지 보겠습니다.

## 함수 만들기

### 같은 기능 다른 함수

```jsx
function A() {
  const handleClick = () => {
    // 같은 코드 1
    callApi();
    setState(...);
  };
}

function B() {
  const handleClick = () => {
    // 같은 코드 2 (눈으로는 똑같이 생김)
    callApi();
    setState(...);
  };
}
```

실무에서 컴포넌트 A와 컴포넌트 B가 **완전히 같은 동작을 하는 버튼**을 갖는 경우가 자주 있습니다.

그런데 엔진 입장에서 보면 이건 이렇게 보입니다.

-   A 안의 함수 리터럴 → “소스 코드 위치 X에 있는 함수”
-   B 안의 함수 리터럴 → “소스 코드 위치 Y에 있는 함수”

즉, **서로 다른 함수 리터럴**입니다.

JIT 입장에서는:

-   A 안의 `handleClick`
-   B 안의 `handleClick`

이 둘은 **이름만 같을 뿐, 완전히 별개의 함수**입니다.

그래서 각자 따로 바이트코드/최적화 정보가 붙을 수 있습니다.

결과적으로 **완전히 같은 동작을 하는 두 개의 함수를, 엔진은 각각 따로 최적화**하게 됩니다.

### 하나의 함수로 공유하기

반대로 이런 코드라면 이야기가 달라집니다.

```jsx
const handleClick = () => {
  callApi();
  setState(...);
};

function A() {
  return <button onClick={handleClick} />;
}

function B() {
  return <button onClick={handleClick} />;
}
```

여기서는

-   `handleClick`이라는 함수 리터럴이 **딱 한 번만 선언**되고,
-   A와 B는 **같은 함수를 참조해서 재사용**하고 있습니다.

엔진 입장에서는:

-   “소스 코드 위치 Z에 있는 `handleClick`이라는 함수 리터럴 하나”
-   그걸 A에서도 쓰고, B에서도 쓰는 구조

가 됩니다.

이 경우:

-   **하나의 바이트코드 / 최적화 정보**를 만들어 두고,
-   같은 함수를 여러 컴포넌트에서 재사용하면서 **실행 히스토리(타입 정보, 호출 패턴 등)를 공유**할 수 있습니다.

그럼 자연스럽게 이런 효과가 생깁니다.

-   A에서 자주 클릭되어 `handleClick`이 “핫”해지면,
-   B에서 같은 함수를 호출할 때도 **이미 최적화된 코드 경로를 같이 쓰게 될 가능성**이 커집니다.
-   반대로 “A 안에 따로, B 안에 따로” 함수를 넣으면,
    엔진은 그냥 “다른 함수 두 개”라고 생각하고 각각 따로 관리합니다.

## 어디서 많이 본 패턴인데?

사실 지금까지 얘기한 내용은 JIT를 공부하지 않았더라도,

**React 쓰는 사람이라면 한 번쯤 들어봤을 법한 이야기**입니다.

-   “공유되는 로직은 **공통 함수로 뽑아라**.”
-   “이벤트 핸들러를 컴포넌트 안에서 매번 새로 만들지 말고, **밖으로 빼서 재사용**해라.”
-   “중복 코드는 함수/유틸로 추상화해라.”

이런 이야기들은 이미

-   **유지보수성** (중복 제거, 한 곳에서 수정)
-   **번들 크기** (같은 코드 여러 번 쓰지 않기)
-   **테스트 용이성** (순수 함수로 분리해서 테스트)

같은 이유로도 충분히 설득력이 있습니다.

여기에 **JIT 입장에서도 이득**이라는 이유가 하나 더 붙은 셈입니다.

-   공통 함수로 뽑으면
    → **한 함수가 여러 곳에서 “핫”해질 수 있는 구조**가 되고,
-   중복 함수로 흩어져 있으면
    → 히스토리가 쪼개져서 **각각 “애매하게 자주 실행되는 함수 여러 개”**가 될 수 있습니다.

## 정리: JIT을 의식해서 코드를 짜는

현실적으로 “이 코드는 엔진이 이렇게 최적화할 테니까 이렇게 써야지”라고

JIT 내부 구현까지 의도해서 코드를 짜는 건 거의 불가능하고, 사실 그럴 필요도 없습니다.

대신 이렇게 생각하면 관리가 쉽습니다.

> “좋은 코드”를 만들 때의 기준 중 하나로
> ‘엔진이 최적화하기 좋은 패턴’을 살짝 곁들인다.

실무에서 가져갈 만한 포인트를 정리해보면:

-   **중복 로직은 공통 함수로 추출해서 재사용하기**
    -   A, B 안에 비슷한 핸들러를 각각 만들지 말고,
        컴포넌트 바깥/공통 유틸로 빼서 한 번만 선언해두기.
-   **핫 패스(자주 실행되는 코드)는 가능한 한 일관된 형태로 유지하기**
    -   같은 함수에 매번 전혀 다른 타입/형태의 인자를 던지는 것보다는,
        “비슷한 모양의 데이터”를 넣어주는 편이 엔진에게 유리합니다.
-   **React에서의 ‘좋은 패턴’을 지키면, JIT도 대체로 따라온다**
    -   공통 컴포넌트/공통 훅/공통 유틸로 추출하는 습관
    -   불필요한 새 함수 생성 줄이기

결국 JIT을 위해 특별한 “트릭”을 써야 한다기보다,

-   **중복 줄이고, 재사용성 높이고, 일관성을 유지하는 코드**를 쓰면
-   그 코드는 **엔진 입장에서도 예측 가능하고 최적화하기 좋은 코드**가 됩니다.

JIT은 우리가 컨트롤할 수 있는 옵션이 아니라,

**우리가 짠 코드를 어떻게든 더 빠르게 돌리려고 노력하는 엔진 쪽 로직**입니다.

그래서 “JIT를 위해서 뭘 더 해야 하지?”보다는

> 이미 알고 있는 좋은 설계 원칙과 리팩터링 습관이
>
> 곧 JIT에게도 친화적인 코드라는 걸 알고 있으면 된다.

정도만 머릿속에 넣어두면,

굳이 매번 JIT을 떠올리지 않아도 자연스럽게 **최적화에 유리한 방향으로 개발**하게 됩니다.
